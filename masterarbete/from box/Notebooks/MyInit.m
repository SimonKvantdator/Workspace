(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetDirectory[NotebookDirectory[]];


(* ::Input::Initialization:: *)
<<xAct`SymManipulator`


(* ::Input::Initialization:: *)
Import["TexActModified.m"]
<<xAct`SpinFrames`


(* ::Input::Initialization:: *)
$PrePrint=ScreenDollarIndices;


(* ::Input::Initialization:: *)
(*<<xAct`ShowTime1`*)


(* ::Input::Initialization:: *)
(*$ShowTimeThreshold=0.1*)


(* ::Input::Initialization:: *)
(*$DefInfoQ=True;
$CVVerbose=False;*)


(* ::Input::Initialization:: *)
(*SetOptions[AutomaticRules,Verbose\[Rule]False]*)


(* ::Input::Initialization:: *)
{$PsiSign=1,$PhiSign=1,$LambdaSign=1,$ChiSign=1,$RicciSign=1,$RiemannSign=-1};


(* ::Input::Initialization:: *)
DefManifold[M4,4,{a,b,c,d,f,h,l,m,p,q}]


(* ::Input::Initialization:: *)
DefMetric[{1,3,0},g[-a,-b],CD,PrintAs->"g",DefInfo->False]


(* ::Input::Initialization:: *)
$DyadCalcInfo=True;


(* ::Input::Initialization:: *)
EqToRule[expr_Equal]:=MakeRule[Evaluate[List@@expr],MetricOn->All,ContractMetrics->True]
EqToRule[True]={};


(* ::Input::Initialization:: *)
EqToRuleN[expr_Equal]:=MakeRule[Evaluate[List@@expr],MetricOn->None,ContractMetrics->False]
EqToRuleN[True]={};


(* ::Input::Initialization:: *)
ToRuleN[expr_Equal]:=MakeRule[Evaluate[List@@expr],MetricOn->None,ContractMetrics->False]
ToRuleN[True]={};


(* ::Input::Initialization:: *)
EqToCompareRule[expr_Equal]:=MakeCompareRule[Evaluate[List@@expr]]


(* ::Input::Initialization:: *)
FlipEquation[LHS_==Times[a_?NumberQ,RHS1_,RHSS2___]]:=Times[RHS1,RHSS2]==(LHS)/a


(* ::Input::Initialization:: *)
FlipEquation[LHS_==RHS_]:=RHS==LHS


(* ::Input::Initialization:: *)
Isolate[LHS_==RHS_,pattern_]:=Module[{eq=LHS-RHS,pos},
pos=First@First@Position[eq,pattern];
FlipEquation[eq[[pos]]-eq==eq[[pos]]]]


(* ::Input::Initialization:: *)
ApplyRule=EqToRule;
ApplyRuleN=EqToRuleN;
ApplyCompareRule=EqToCompareRule;


(* ::Input::Initialization:: *)
ExpandBoxInSym[expr_]:=ToCanonicalSym@ContractMetricsInsideSym@FunctionInSym[expr,ExpandBox]


(* ::Input::Initialization:: *)
RemoveSignFromEq[-x_==y_]:=x==-y;


(* ::Input::Initialization:: *)
RemoveSignFromEq[x_==y_]:=x==y;


(* ::Input::Initialization:: *)
RemoveSignFromEq[-x_->y_]:=x->-y;


(* ::Input::Initialization:: *)
RemoveSignFromEq[x_->y_]:=x->y;


(* ::Input::Initialization:: *)
RemoveSignFromEq[x_]:=x;


(* ::Input::Initialization:: *)
PlaceIndicesInSpinor[TT_?xTensorQ,{inds___},{spin_,spindg_}]:=With[{slotsTT=SlotsOfTensor@TT,unprimedinds=Select[{inds},VBundleOfIndex[#]==spin&],primedinds=Select[{inds},VBundleOfIndex[#]==spindg&]},
With[{unprimedpos=Select[Range@Length@slotsTT,(UpIndex[slotsTT[[#]]]==spin)&],primedpos=Select[Range@Length@slotsTT,(UpIndex[slotsTT[[#]]]==spindg)&]},TT[Sequence@@(Range@Length@slotsTT/.Join[Thread[primedpos->primedinds],Thread[unprimedpos->unprimedinds],xAct`SymManipulator`Private`SlotRulesOtherVBs[slotsTT,{inds},spin,spindg]])]]]


(* ::Input::Initialization:: *)
Tex[\[Epsilon]\[Dagger]]^="\\bar\\epsilon";


(* ::Input::Initialization:: *)
Tex[PsiCDe\[Dagger]]^="\\bar\\Psi";


(* ::Input::Initialization:: *)
SetOptions[TexBreak,TexBreakString->" \\nonumber \\\\ \n &"];


(* ::Input::Initialization:: *)
Off[ValidateSymbol::"capital"]


(* ::Input::Initialization:: *)
SetOptions[DefFundSpinOperators,ShowValenceInfo->False]


(* ::Input::Initialization:: *)
SetOptions[DefAbstractIndex,PrintAs->PrimeDagger]


(* ::Input::Initialization:: *)
SetOptions[DefSpinor,PrintDaggerAs->AddBar]


(* ::Input::Initialization:: *)
DefSpinStructure[g,Spin,{A,B,C,D,F,H,L,M,P,Q,R,S},\[Epsilon],\[Sigma],CDe,{";","\[EmptyDownTriangle]"},SpinorPrefix->SP,SpinorMark->"S"]


(* ::Input::Initialization:: *)
{PrintAs[PsiCDe]^="\[CapitalPsi]",PrintAs[PhiCDe]^="\[CapitalPhi]",PrintAs[LambdaCDe]^="\[CapitalLambda]"};


(* ::Input::Initialization:: *)
xAct`SpinFrames`Private`PrintDaggerAsBar/@{\[Epsilon],PsiCDe}


(* ::Input::Initialization:: *)
$CVVerbose=False;


(* ::Input::Initialization:: *)
DefFundSpinOperators@CDe;


(* ::Input::Initialization:: *)
DefNPTetrad[NP,{lNP[a],nNP[a],mNP[a]}]


(* ::Input::Initialization:: *)
DefSpinDyad[Dyad,{o[A],\[Iota][A]},NP]


(* ::Input::Initialization:: *)
PsiCDeToDyad=DyadExpansionEq[PsiCDe,Dyad];


(* ::Input::Initialization:: *)
PsiCDe\[Dagger]ToDyad=DyadExpansionEq[PsiCDe\[Dagger],Dyad];


(* ::Input::Initialization:: *)
CDeToNPRule=CovDToNPRules[Dyad];


(* ::Input::Initialization:: *)
AllGHPCommutatorsForward=GHPCommutatorsForward[Dyad];


(* ::Input::Initialization:: *)
AllGHPCommutatorsBackward=GHPCommutatorsBackward[Dyad];


(* ::Input::Initialization:: *)
DyadComponents[expr_]:=DyadComponents[expr,Dyad];


(* ::Input::Initialization:: *)
GHPWeightRules[expr_]:=GHPWeightRules[expr,Dyad];


(* ::Input::Initialization:: *)
ToGHP[expr_]:=ToGHP[expr,Dyad];


(* ::Input::Initialization:: *)
SortByGHPOrderNoExpansion[expr_]:=Block[{xAct`xTensor`Private`MathInputExpand=Identity},SortByGHPOrder@expr]


(* ::Input::Initialization:: *)
SetAttributes[TexPrintAlignedEquationsLongLHS,HoldFirst];
Options[TexPrintAlignedEquationsLongLHS]={Labels->False,LHSshift->"6ex"};


(* ::Input::Initialization:: *)
TexPrintAlignedEquationsLongLHS[eqlist:{eqs___},OptionsPattern[]]:=Module[{TexLHS=TexPrint[xAct`TexAct`Private`LHSpart@#]&/@eqlist,TexRHS=TexPrint[xAct`TexAct`Private`RHSpart@#]&/@eqlist,LHSWidth,MaxRHSWidth,pagewidth,eqnames={ReleaseHold[ToString/@HoldForm/@Hold[eqs]]},space},space=OptionValue[LHSshift];{pagewidth,LHSWidth}=xAct`TexAct`Private`TexWidths[{StringJoin["\\hspace{",space,"}"]}];
MaxRHSWidth=Round[($TexPrintPageWidth/.latextextwidth->pagewidth)-LHSWidth];
TexLHS=TexBreak[#,1,TexBreakBy->"Term",TexBreakString->"\n"]&/@TexLHS;
TexLHS=TexBreak[#,$TexPrintPageWidth,TexBreakBy->"TexPoint",TexBreakString->"\\nonumber\\\\\n&"]&/@TexLHS;
TexLHS=StringReplace[#,"\n\\nonumber"->"\\nonumber"]&/@TexLHS;
TexRHS=TexBreak[#,1,TexBreakBy->"Term",TexBreakString->"\n"]&/@TexRHS;
TexRHS=TexBreak[#,MaxRHSWidth,TexBreakBy->"TexPoint",TexBreakString->"\\nonumber\\\\\n&"]&/@TexRHS;
TexRHS=StringReplace[#,"\n\\nonumber"->"\\nonumber"]&/@TexRHS;
StringJoin["\\begin{align}\n",StringReplace[StringJoin[Riffle[MapThread[StringJoin["\\hspace{",space,"}&\\hspace{-",space,"}",#1,"\\nonumber\\\\\n={}&",#2,If[And[OptionValue[Labels],NameQ[#3]],StringJoin[" \\label{",TexLabelName[#3],"}"],""]]&,{TexLHS,TexRHS,eqnames}],",\\\\\n"]],",\\\\\n="->"\\\\\n="],".\n\\end{align}"]]
TexPrintAlignedEquationsLongLHS[other_,x___]:=TexPrintAlignedEquationsLongLHS[Evaluate@other,x]


(* ::Input::Initialization:: *)
ExtractUnprimedAndPrimed[spin_]:={Select[#,xAct`xTensor`Private`VBundleIndexPMQ@spin],Select[#,xAct`xTensor`Private`VBundleIndexPMQ@Dagger@spin]}&


(* ::Input::Initialization:: *)
NumOfUnprimedVBundles[spin_]:=Length@Cases[UpIndex/@#,spin]&;
NumOfPrimedVBundles[spin_]:=Length@Cases[UpIndex/@#,Dagger@spin]&;
NumOfUnprimedSlots[spin_]:=Length@Cases[UpIndex/@SlotsOfTensor@#,spin]&;
NumOfPrimedSlots[spin_]:=Length@Cases[UpIndex/@SlotsOfTensor@#,Dagger@spin]&;
NumOfUnprimedSlotsDyad[dyad_]:=NumOfUnprimedSlots[VBundleOfBasis@dyad];
NumOfPrimedSlotsDyad[dyad_]:=NumOfPrimedSlots[VBundleOfBasis@dyad];


(* ::Input::Initialization:: *)
SymmetricSpinorOfValenceQ[k_,l_,spin_]:=And[xTensorQ[#],CompatibleSymQ[SlotsOfTensor[#],SymmetryGroupOfTensor@#],ValenceNumbersOfSpinor[#,spin]==={k,l}]&


(* ::Input::Initialization:: *)
SymmetricSpinorOfArbitraryValenceQ[spin_][TT_?xTensorQ]:=With[{k=NumOfUnprimedSlots[Spin][TT],l=NumOfPrimedSlots[Spin][TT]},SymmetricSpinorOfValenceQ[spin,k,l][TT]]


(* ::Input::Initialization:: *)
xTensorQ[MultScal[scal_,LL_?xTensorQ]]^=True;


(* ::Input::Initialization:: *)
SlotsOfTensor[MultScal[scal_,LL_?xTensorQ]]^:=SlotsOfTensor[LL];


(* ::Input::Initialization:: *)
SymmetryGroupOfTensor[MultScal[scal_,LL_?xTensorQ]]^:=SymmetryGroupOfTensor[LL]


(* ::Input::Initialization:: *)
PrintAs[MultScal[scal_Plus,LL_?xTensorQ]]^:=RowBox[{"(","(",MakeBoxes[scal,StandardForm],")",PrintAs[LL],")"}];
PrintAs[MultScal[-1,LL_?xTensorQ]]^:=RowBox[{"(","-",PrintAs[LL],")"}];PrintAs[MultScal[scal_,LL_?xTensorQ]]^:=RowBox[{"(",MakeBoxes[scal,StandardForm],PrintAs[LL],")"}];


(* ::Input::Initialization:: *)
MultScalRule=MultScal[scal_,LL_][inds___]:>scal*LL[inds];


(* ::Input::Initialization:: *)
MultScal[1,expr_]:=expr;


(* ::Input::Initialization:: *)
Tex[MultScal[scal_,MultScal[secondscal_,LL_?xTensorQ]]]^:=StringJoin[xAct`TexAct`Private`TexOpen["("],xAct`TexAct`Private`TexFactor[scal],xAct`TexAct`Private`TexFactor[secondscal],xAct`TexAct`Private`TexFactor[LL],xAct`TexAct`Private`TexClose[")"]];


(* ::Input::Initialization:: *)
Tex[MultScal[scal_,LL_?xTensorQ]]^:=StringJoin[xAct`TexAct`Private`TexOpen["("],xAct`TexAct`Private`TexFactor[scal],xAct`TexAct`Private`TexFactor[LL],xAct`TexAct`Private`TexClose[")"]];


(* ::Input::Initialization:: *)
MultScal[scal_,ZeroTensor[vbs_]]:=ZeroTensor[vbs];


(* ::Input::Initialization:: *)
$KopExclude={};


(* ::Input::Initialization:: *)
ImposeMultScal[expr_Plus,scal_]:=ImposeMultScal[#,scal]&/@expr;
ImposeMultScal[expr_Equal,scal_]:=ImposeMultScal[#,scal]&/@expr;
ImposeMultScal[0,scal_]:=0;
ImposeMultScal[expr_,0]:=0;
ImposeMultScal[c_?ConstantQ*expr_,scal_]:=c*ImposeMultScal[expr,scal];
ImposeMultScal[TT_?xTensorQ[tinds___],scal_]:=MultScal[scal,TT][tinds];
ImposeMultScal[expr_Times,scal_]:=With[{factorlist=xAct`xTensor`Private`ListOfFactors@expr},Times@@Select[factorlist,Function[x,Not@AllTrue[$KopExclude,FreeQ[x,#]&]]]*ImposeMultScal2[Times@@Select[factorlist,Function[x,AllTrue[$KopExclude,FreeQ[x,#]&]]],scal]]
ImposeMultScal2[TT_?xTensorQ[tinds___],scal_]:=MultScal[scal,TT][tinds];
ImposeMultScal2[Times[TT_?xTensorQ[tinds1___],z__],scal_]:=Times[MultScal[scal,TT][tinds1],z];
ImposeMultScal2[z_,scal_]:=Times[z,scal]


(* ::Input::Initialization:: *)
DaggerTensor[expr_]:=Which[HermitianQ[expr],expr,AntihermitianQ[expr],MultScal[-1,expr],True,Dagger[expr]]


(* ::Input::Initialization:: *)
TensorPlus[0,more___]:=TensorPlus[more];
TensorPlus[z__,0,more___]:=TensorPlus[z,more];


(* ::Input::Initialization:: *)
TensorPlus[TensorPlus[expr__],z___]:=TensorPlus[expr,z];
TensorPlus[x__,TensorPlus[expr__],z___]:=TensorPlus[x,expr,z];


(* ::Input::Initialization:: *)
SymmetricSpinorOfValenceQ[k_,l_,spin_][TensorPlus[arg__]]^:=And@@(SymmetricSpinorOfValenceQ[k,l,spin]/@List[arg]);


(* ::Input::Initialization:: *)
Dagger[TensorPlus[arg___]]^:=DaggerTensor/@TensorPlus[arg]


(* ::Input::Initialization:: *)
PrintAsNoPar[MultScal[scal_Plus,LL_?xTensorQ]]^:=RowBox[{"(",MakeBoxes[scal,StandardForm],")",PrintAs[LL]}];
PrintAsNoPar[MultScal[-1,LL_?xTensorQ]]^:=RowBox[{"-",PrintAs[LL]}];
PrintAsNoPar[MultScal[scal_,LL_?xTensorQ]]^:=RowBox[{MakeBoxes[scal,StandardForm],PrintAs[LL]}];
PrintAsNoPar[expr___]:=PrintAs[expr]


(* ::Input::Initialization:: *)
PrintAs[TensorPlus[expr1_,expr2___]]^:=RowBox[Join[{xAct`xTensor`Private`interpretbox[expr1,PrintAsNoPar[expr1]]},Join@@(If[xAct`SpinFrames`Private`BoxStartWithMinusQ[#[[2]]],{xAct`xTensor`Private`interpretbox@@#},{"+",xAct`xTensor`Private`interpretbox@@#}]&/@({#,PrintAsNoPar[#]}&/@List[expr2]))]]


(* ::Input::Initialization:: *)
Tex[TensorPlus[expr___]]^:=StringJoin[Riffle[xAct`SymManipulator`Private`TexFundOp/@List[expr]," + "]];


(* ::Input::Initialization:: *)
ToTensorPlusRules={Plus[T1_?TensorQ,T2_?TensorQ]:>TensorPlus[T1,T2],c_?ConstantQ*T_?TensorQ:>MultScal[c,T]};


(* ::Input::Initialization:: *)
TensorPlusSortFunc[MultScal[a_,b_]]:=TensorPlusSortFunc[b];
TensorPlusSortFunc[b_]:=b;


(* ::Input::Initialization:: *)
SortTensorPlusRule=expr_TensorPlus:>SortBy[expr,TensorPlusSortFunc];


(* ::Input::Initialization:: *)
EqToTensorOpRule[lhs_==0]:=TermToOp[lhs]->ZeroTensor@SlotsOfTensor@TermToOp[lhs];EqToTensorOpRule[lhs_==rhs_]:=TermToOp[lhs]:>Evaluate[TensorPlus@@TermToOp/@xAct`xTensor`Private`ListOfTerms[rhs]];


(* ::Input::Initialization:: *)
MakeBoxes[TensorMatrix[matrix_List],StandardForm]:=xAct`xTensor`Private`interpretbox[TensorMatrix[matrix],RowBox[{"(",Map[PrintAs,GridBox[matrix],{3}],")"}]]


(* ::Input::Initialization:: *)
Tex[TensorMatrix[matrix_List]]:=StringJoin["{",TexMatrix[matrix],"}"];


(* ::Input::Initialization:: *)
SetDelayed[MatrixOpQ[_],False]


(* ::Input::Initialization:: *)
SetNumberOfArguments[MatrixOpQ,1]


(* ::Input::Initialization:: *)
Protect[MatrixOpQ];


(* ::Input::Initialization:: *)
SetAttributes[HeldMatrixOpQ,HoldAllComplete];
HeldMatrixOpQ[expr_]:=MatrixOpQ[Unevaluated[expr]];


Tex[MatrixOp[opmatrix_List]] := TexMatrix[opmatrix, xAct`SymManipulator`Private`TexFundOp ]


(* ::Input::Initialization:: *)
Tex[MatrixOp[opmatrix_List][TensorMatrix[tmatrix_List]]]:=StringJoin["{",Tex[MatrixOp[opmatrix]],"}{",TexMatrix[tmatrix],"}"]


(* ::Input::Initialization:: *)
MakeBoxes[MatrixOp[matrix_List],StandardForm]:=xAct`xTensor`Private`interpretbox[MatrixOp[matrix],RowBox[{"(",Map[PrintAsNoPar,GridBox[matrix],{3}],")"}]]


xTensorFormStart[MatrixOp]:=(
MakeBoxes[ih_?HeldMatrixOpQ[expr_],StandardForm]:=xAct`xTensor`Private`interpretbox[ih[expr],RowBox[{PrintAs[Unevaluated[ih]],"[",MakeBoxes[expr,StandardForm],"]"}]];
MakeBoxes[ih_?HeldMatrixOpQ,StandardForm]:=xAct`xTensor`Private`interpretbox[ih,RowBox[{PrintAs[Unevaluated[ih]]}]]);
xTensorFormStop[MatrixOp]:=(MakeBoxes[ih_?HeldMatrixOpQ[expr_],StandardForm]=.;MakeBoxes[ih_?HeldMatrixOpQ,StandardForm]=.);
xTensorFormStart[MatrixOp]


(* ::Input::Initialization:: *)
MultScal/:Tex[MultScal[scal_,MultScal[secondscal_,LL_?xTensorQ]]]=.


(* ::Input::Initialization:: *)
xAct`SymManipulator`Private`TexFundOp[MultScal[scal_,LL_?xTensorQ]]^:=StringJoin[xAct`TexAct`Private`TexFactor[scal],xAct`SymManipulator`Private`TexFundOp[LL]];


(* ::Input::Initialization:: *)
Tex[MultScal[scal_,LL_?xTensorQ]]^:=StringJoin[xAct`TexAct`Private`TexOpen["("],xAct`TexAct`Private`TexFactor[scal],xAct`SymManipulator`Private`TexFundOp[LL],xAct`TexAct`Private`TexClose[")"]];


(* ::Input::Initialization:: *)
xTensorQ[DummyTensor[vbs_,sym_]]^=True;
SlotsOfTensor[DummyTensor[vbs_,sym_]]^:=vbs;
SymmetryGroupOfTensor[DummyTensor[vbs_,sym_]]^:=sym;
PrintAs[DummyTensor[vbs_,sym_]]^="";
Tex[DummyTensor[vbs_,sym_]]^="";
TensorToDummyTensor[TT_?xTensorQ]:=TT->DummyTensor[SlotsOfTensor[TT],SymmetryGroupOfTensor[TT]]


(* ::Input::Initialization:: *)
SymmetricDummySpinor[k_,l_]:=With[{vbs=Join[ConstantArray[-Spin,k],ConstantArray[-Spin\[Dagger],l]]},DummyTensor[vbs,xAct`SymManipulator`Private`CompatibleSym@vbs]]


(* ::Input::Initialization:: *)
Dagger[DummyTensor[vbs_,sym_]]^:=DummyTensor[Reverse[Dagger/@vbs],xAct`SymManipulator`Private`CompatibleSym@Reverse[Dagger/@vbs]]/;CompatibleSymQ[vbs,sym]


(* ::Input::Initialization:: *)
Dagger[DummyTensor[vbs_,sym_][inds___]]^:=PlaceIndicesInTensor[Evaluate@Dagger[DummyTensor[vbs,sym]],DaggerIndex/@{inds}]


(* ::Input::Initialization:: *)
ExprToIndexFreeTensor[0]:=0;
ExprToIndexFreeTensor[expr_Plus]:=TensorPlus@@(ExprToIndexFreeTensor/@expr);
ExprToIndexFreeTensor[c_?ConstantQ*expr_]:=MultScal[c,ExprToIndexFreeTensor[expr]];
ExprToIndexFreeTensor[TT_?xTensorQ[]*expr_]:=MultScal[TT[],ExprToIndexFreeTensor[expr]];
ExprToIndexFreeTensor[TT_?xTensorQ[inds___]]:=TT;


(* ::Input::Initialization:: *)
MatrixOpRule=MatrixOp[opmatrix_List][TensorMatrix[tmatrix_List]]:>Module[{},TensorMatrix@Inner[#1/.Reverse[TensorToDummyTensor[#2]/.DummyTensor[vbs_,sym_]:> DummyTensor[vbs,_]]&,opmatrix,tmatrix,TensorPlus]];


(* ::Input::Initialization:: *)
TensorMatrixToList=TensorMatrix[tmatrix_List]:>Map[GiveIndicesToTensor,tmatrix,{2}];


(* ::Input::Initialization:: *)
TensorMatrixEqToList[expr_Equal]:=Expand[Flatten[Thread/@Thread[expr/.TensorMatrixToList]]//.MultScalRule];


(* ::Input::Initialization:: *)
ExprToIndexFreeTensor2[lia_List,vbs_]:=ExprToIndexFreeTensor[#,vbs]&/@lia


(* ::Input::Initialization:: *)
EqListToTensorMatrixEq[teqlist_List,vars_List]:=TensorMatrix[Transpose[{Head/@(First/@teqlist)}]]==MatrixOp[Map[ExprToIndexFreeTensor,Outer[((#1[[2]]-(#1[[2]]/.TensorToZeroRule[#2]))/.TensorToDummyTensor[#2])&,teqlist,vars],{2}]]@TensorMatrix[Transpose[{vars}]]


(* ::Input::Initialization:: *)
InertHeadQ[Mult[factor_]]^=True;
DefInfo[Mult[factor_]]^={"inert head",""};
PrintAs[Mult[factor_Plus]]^:=RowBox[{"(",MakeBoxes[factor,StandardForm],")"}];
PrintAs[Mult[factor_]]^:=MakeBoxes[factor,StandardForm];
Tex[Mult[factor_][expr_]]^:=StringJoin[xAct`TexAct`Private`TexOpen["("],xAct`TexAct`Private`TexFactor[factor],xAct`TexAct`Private`TexFactor[expr],xAct`TexAct`Private`TexClose[")"]];
MultRule=Mult[factor_][expr_]:>factor*expr;
Mult[1][expr_]:=expr;
Mult[_][0]:=0;
Mult[0][_]:=0;
GHPWeightOf[Mult[factor_][expr_]]:=GHPWeightOf[factor*expr];


(* ::Input::Initialization:: *)
xTensorFormStop[InertHead];


(* ::Input::Initialization:: *)
MakeBoxes[Mult[factor_][expr_Plus],StandardForm]:=xAct`xTensor`Private`interpretbox[Mult[factor][expr],RowBox[{"(",PrintAs[Unevaluated[Mult[factor]]],"(",MakeBoxes[expr,StandardForm],")",")"}]];
MakeBoxes[Mult[factor_Plus][expr_],StandardForm]:=xAct`xTensor`Private`interpretbox[Mult[factor][expr],RowBox[{"(","(",PrintAs[Unevaluated[Mult[factor]]],")",MakeBoxes[expr,StandardForm],")"}]];
MakeBoxes[Mult[factor_][expr_],StandardForm]:=xAct`xTensor`Private`interpretbox[Mult[factor][expr],RowBox[{"(",PrintAs[Unevaluated[Mult[factor]]],MakeBoxes[expr,StandardForm],")"}]];


(* ::Input::Initialization:: *)
xTensorFormStart[InertHead];


(* ::Input::Initialization:: *)
EqToOpRule[lhs_==rhs_]:=RuleDelayed[OpToPatternOp@TermToOp@lhs,Evaluate[TensorPlus@@(TermToOp/@xAct`xTensor`Private`ListOfTerms[rhs])]]


(* ::Input::Initialization:: *)
TermToOp[TT_?xTensorQ[inds___]]:=TT
TermToOp[c_?ConstantQ*z_]:=MultScal[c,TermToOp[z]];
TermToOp[c_?xTensorQ[]*z_]:=MultScal[c[],TermToOp[z]];
TermToOp[(c_?xTensorQ[])^(i_)*z_]:=MultScal[c[]^i,TermToOp[z]];
OpToPatternOp[op_[TT_?xTensorQ]]:=op[TT]/.TT->xAct`xTensor`Private`pattern[TT,_]/.xAct`xTensor`Private`pattern->Pattern


(* ::Input::Initialization:: *)
SetLinearOperatorRules[op_]:=Module[{},
LinearOperatorQ[op]^=True;
op[expr_TensorPlus,z___]:=op[#,z]&/@expr;
op[ZeroTensor[vbs_],z___]:=ZeroTensor@SlotsOfTensor@op[DummyTensor[vbs,CompatibleSymmetric[vbs]],z];
op[MultScal[c_?ConstantQ,TT_?xTensorQ],z___]:=MultScal[c,op[TT,z]];
]


(* ::Input::Initialization:: *)
MultScal[c_,expr_TensorPlus]:=MultScal[c,#]&/@expr


(* ::Input::Initialization:: *)
MultScal[c1_?ConstantQ,MultScal[c2_?ConstantQ,TT_?xTensorQ]]:=MultScal[c1*c2,TT]


(* ::Input::Initialization:: *)
MultScal[c1_,MultScal[c2_?ConstantQ,TT_?xTensorQ]]:=MultScal[c2,MultScal[c1,TT]]


(* ::Input::Initialization:: *)
TensorPlus[z___,a_,f___,MultScal[c_,a_],d___]:=TensorPlus[z,MultScal[c+1,a],f,d];
TensorPlus[z___,MultScal[c_,a_],f___,a_,d___]:=TensorPlus[z,MultScal[c+1,a],f,d];
TensorPlus[z___,MultScal[b_,a_],f___,MultScal[c_,a_],d___]:=TensorPlus[z,MultScal[b+c,a],f,d];
TensorPlus[z___,a_,b___,a_,d___]:=TensorPlus[z,MultScal[2,a],b,d]


(* ::Input::Initialization:: *)
CombineMultScalRule=MultScal[a_,MultScal[b_,c_]]:>MultScal[a*b,c];


(* ::Input::Initialization:: *)
UnCombineMultScalRule=MultScal[Times[a_,b__],c_]:>MultScal[a,MultScal[Times[b],c]];


(* ::Input::Initialization:: *)
SetLinearOperatorRules@DivCDe
SetLinearOperatorRules@CurlCDe
SetLinearOperatorRules@CurlDgCDe
SetLinearOperatorRules@TwistCDe


(* ::Input::Initialization:: *)
AdjointOp[op1_,var1_][TensorPlus[tensors___]]:=AdjointOp[op1,var1]/@TensorPlus[tensors];
AdjointOp[op1_,var1_][MultScal[c_?ConstantQ,TT_?xTensorQ]]:=MultScal[c,AdjointOp[op1,var1][TT]];
AdjointOp[op1_,var1_][ZeroTensor[vbs_]]:=ZeroTensor@SlotsOfTensor[var1];
HermAdjOp[op1_,var1_][TensorPlus[tensors___]]:=HermAdjOp[op1,var1]/@TensorPlus[tensors];
HermAdjOp[op1_,var1_][MultScal[c_?ConstantQ,TT_?xTensorQ]]:=MultScal[c,HermAdjOp[op1,var1][TT]];
HermAdjOp[op1_,var1_][ZeroTensor[vbs_]]:=ZeroTensor@SlotsOfTensor[Dagger@var1];


(* ::Input::Initialization:: *)
ExpandSymS[LL_]:=ExpandSym[LL,SmartExpand->True]


(* ::Input::Initialization:: *)
CommuteOp::usage="CommuteOp[op1, op2]";


(* ::Input::Initialization:: *)
Unprotect[ConstantQ];


(* ::Input::Initialization:: *)
ConstantQ[expr_Plus]:=And@@(ConstantQ/@(List@@expr))
ConstantQ[expr_Times]:=And@@(ConstantQ/@(List@@expr))


(* ::Input::Initialization:: *)
ConstantQ[-expr_]:=ConstantQ[expr];


(* ::Input::Initialization:: *)
Protect[ConstantQ];


(* ::Input::Initialization:: *)
xTensorQ[TensorPlus[TT_?xTensorQ,more__]]^:=True;


(* ::Input::Initialization:: *)
SlotsOfTensor[TensorPlus[TT_?xTensorQ,more__]]^:=SlotsOfTensor@TT;


(* ::Input::Initialization:: *)
TensorPlus[TT_?xTensorQ]:=TT;


(* ::Input::Initialization:: *)
TensorPlus[tensors___][inds___]:=Plus@@(#[inds]&/@List[tensors])


(* ::Input::Initialization:: *)
DivCDe[TensorPlus[tensors___]]:=DivCDe/@TensorPlus[tensors];
CurlCDe[TensorPlus[tensors___]]:=CurlCDe/@TensorPlus[tensors];
CurlDgCDe[TensorPlus[tensors___]]:=CurlDgCDe/@TensorPlus[tensors];
TwistCDe[TensorPlus[tensors___]]:=TwistCDe/@TensorPlus[tensors];


(* ::Input::Initialization:: *)
SymmetricOfValence[k_?NumericQ,l_?NumericQ,spin_]:=Join[ConstantArray[-spin,k],ConstantArray[-Dagger@spin,l]]


(* ::Input::Initialization:: *)
SetAttributes[HeldxTensorQ,HoldAllComplete];
HeldxTensorQ[expr_]:=xTensorQ[Unevaluated[expr]];
MakeBoxes[tensor_?HeldxTensorQ,StandardForm]:=xAct`xTensor`Private`interpretbox[tensor,xAct`xTensor`Private`xTensorBox[tensor,{}]]


(* ::Input::Initialization:: *)
EnoughIndsQSpin=Function[{TTT,k,l},And[Simplify[NumOfUnprimedSlots[Spin][TTT]>=k],Simplify[NumOfPrimedSlots[Spin][TTT]>=l]]];


(* ::Input::Initialization:: *)
TensorPlus[z__,ZeroTensor[vbs_],more___]:=TensorPlus[z,more];
TensorPlus[ZeroTensor[vbs_],more___]:=TensorPlus[more];


(* ::Input::Initialization:: *)
NumOfUnprimedSlots[Spin][ZeroTensor[SymmetricOfValence[k_,l_,Spin]]]^:=k;
NumOfPrimedSlots[Spin][ZeroTensor[SymmetricOfValence[k_,l_,Spin]]]^:=l;


(* ::Input::Initialization:: *)
NumOfUnprimedSlots[Spin][TensorPlus[TT_?xTensorQ,more__]]^:=NumOfUnprimedSlots[Spin]@TT;
NumOfPrimedSlots[Spin][TensorPlus[TT_?xTensorQ,more__]]^:=NumOfPrimedSlots[Spin]@TT;


(* ::Input::Initialization:: *)
xAct`TexAct`Private`TexFactor[expr_TensorPlus]:=StringJoin[xAct`TexAct`Private`TexOpen["("],Tex[expr],xAct`TexAct`Private`TexClose[")"]];


(* ::Input::Initialization:: *)
xAct`SymManipulator`Private`TexFundOp[expr_TensorPlus]:=xAct`TexAct`Private`TexFactor[expr];


(* ::Input::Initialization:: *)
NumOfUnprimedSlots[Spin][DivCDe[TT_?xTensorQ]]^:=NumOfUnprimedSlots[Spin][TT]-1;
NumOfPrimedSlots[Spin][DivCDe[TT_?xTensorQ]]^:=NumOfPrimedSlots[Spin][TT]-1;
NumOfUnprimedSlots[Spin][CurlCDe[TT_?xTensorQ]]^:=NumOfUnprimedSlots[Spin][TT]+1;
NumOfPrimedSlots[Spin][CurlCDe[TT_?xTensorQ]]^:=NumOfPrimedSlots[Spin][TT]-1;
NumOfUnprimedSlots[Spin][CurlDgCDe[TT_?xTensorQ]]^:=NumOfUnprimedSlots[Spin][TT]-1;
NumOfPrimedSlots[Spin][CurlDgCDe[TT_?xTensorQ]]^:=NumOfPrimedSlots[Spin][TT]+1;
NumOfUnprimedSlots[Spin][TwistCDe[TT_?xTensorQ]]^:=NumOfUnprimedSlots[Spin][TT]+1;
NumOfPrimedSlots[Spin][TwistCDe[TT_?xTensorQ]]^:=NumOfPrimedSlots[Spin][TT]+1;


(* ::Input::Initialization:: *)
DivCDe[ZeroTensor[SymmetricOfValence[k_,l_,Spin]]]:=ZeroTensor[SymmetricOfValence[k-1,l-1,Spin]];
CurlCDe[ZeroTensor[SymmetricOfValence[k_,l_,Spin]]]:=ZeroTensor[SymmetricOfValence[k+1,l-1,Spin]];
CurlDgCDe[ZeroTensor[SymmetricOfValence[k_,l_,Spin]]]:=ZeroTensor[SymmetricOfValence[k-1,l+1,Spin]];
TwistCDe[ZeroTensor[SymmetricOfValence[k_,l_,Spin]]]:=ZeroTensor[SymmetricOfValence[k+1,l+1,Spin]];


(* ::Input::Initialization:: *)
ZeroTensorFromSymmetricSpinor[TT_?xTensorQ]:=ZeroTensor[SymmetricOfValence[NumOfUnprimedSlots[Spin][TT],NumOfPrimedSlots[Spin][TT],Spin]]


(* ::Input::Initialization:: *)
MultScal[0,TT_?xTensorQ]:=ZeroTensorFromSymmetricSpinor@TT;


(* ::Input::Initialization:: *)
printfunc2[TT4_,symbstringstart_, symbstringend_,simplesymb_]:=StringJoin[\!\(\*
TagBox[
StyleBox["symbstringstart",
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),ToString[DisplayForm@NumOfUnprimedSlots[Spin][TT4],StandardForm],",",ToString[DisplayForm@NumOfPrimedSlots[Spin][TT4],StandardForm],symbstringend];


(* ::Input::Initialization:: *)
TexValenceNumbers[TT_]:=If[OptionValue[DefFundSpinOperators,ShowValenceInfo],StringJoin["_{",Tex[NumOfUnprimedSlots[Spin][TT]/.ToOrderedPlus],",",Tex[NumOfPrimedSlots[Spin][TT]/.ToOrderedPlus],"} "]," "];


(* ::Input::Initialization:: *)
xAct`SymManipulator`Private`TexFundOp[DivCDe[TT_?xTensorQ]]^:=StringJoin["\\sDiv",TexValenceNumbers[TT],xAct`SymManipulator`Private`TexFundOp[TT]];
xAct`SymManipulator`Private`TexFundOp[CurlCDe[TT_?xTensorQ]]^:=StringJoin["\\sCurl",TexValenceNumbers[TT],xAct`SymManipulator`Private`TexFundOp[TT]];
xAct`SymManipulator`Private`TexFundOp[CurlDgCDe[TT_?xTensorQ]]^:=StringJoin["\\sCurlDagger",TexValenceNumbers[TT],xAct`SymManipulator`Private`TexFundOp[TT]];
xAct`SymManipulator`Private`TexFundOp[TwistCDe[TT_?xTensorQ]]^:=StringJoin["\\sTwist",TexValenceNumbers[TT],xAct`SymManipulator`Private`TexFundOp[TT]];


(* ::Input::Initialization:: *)
PrintAs[ZeroTensor[vbs_]]^:=RowBox[{printfunc2[ZeroTensor[vbs],\!\(\*
TagBox[
StyleBox["\"\<\\!\\(\\*SubscriptBox[\\(0\\), \\(\>\"",
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),"\)]\)","0"],""}];


(* ::Input::Initialization:: *)
Tex[ZeroTensor[vbs_]]^="0";


(* ::Input::Initialization:: *)
xTensorQ[SymMult[AA_?xTensorQ,unprim_,prim_][BB_?xTensorQ]]^=True;


(* ::Input::Initialization:: *)
SlotsOfTensor[SymMult[AA_?xTensorQ,unprim_,prim_][BB_?xTensorQ]]^:=Join[ConstantArray[-Spin,NumOfUnprimedVBundles[Spin][SlotsOfTensor[AA]]+NumOfUnprimedVBundles[Spin][SlotsOfTensor[BB]]-2unprim],ConstantArray[-Spin\[Dagger],NumOfPrimedVBundles[Spin][SlotsOfTensor[AA]]+NumOfPrimedVBundles[Spin][SlotsOfTensor[BB]]-2prim]];


(* ::Input::Initialization:: *)
SymmetryGroupOfTensor[SymMult[AA_?xTensorQ,unprim_,prim_][BB_?xTensorQ]]^:=xAct`SymManipulator`Private`CompatibleSym@SlotsOfTensor[SymMult[AA,unprim,prim][BB]];


(* ::Input::Initialization:: *)
SymMultRule=SymMult[AA_?xTensorQ,unprim_,prim_][BB_?xTensorQ][inds___]:>Module[{unprimdummies=DummyIn/@Table[Spin,unprim],primdummies=DummyIn/@Table[Spin\[Dagger],prim],unprimedinds=Select[{inds},Spin`pmQ],primedinds=Select[{inds},Spin\[Dagger]`pmQ],numunprimA=NumOfUnprimedVBundles[Spin][SlotsOfTensor[AA]],numprimA=NumOfPrimedVBundles[Spin][SlotsOfTensor[AA]],numunprimB=NumOfUnprimedVBundles[Spin][SlotsOfTensor[BB]],numprimB=NumOfPrimedVBundles[Spin][SlotsOfTensor[BB]]},
ImposeSym[PlaceIndicesInSpinor[AA,{Sequence@@unprimdummies,Sequence@@(Take[unprimedinds,numunprimA-unprim]),Sequence@@primdummies,Sequence@@(Take[primedinds,numprimA-prim])},{Spin,Spin\[Dagger]}]PlaceIndicesInSpinor[BB,{Sequence@@(ChangeIndex/@unprimdummies),Sequence@@(Take[unprimedinds,-(numunprimB-unprim)]),Sequence@@(ChangeIndex/@primdummies),Sequence@@(Take[primedinds,-(numprimB-prim)])},{Spin,Spin\[Dagger]}],IndexList[inds]]];


(* ::Input::Initialization:: *)
PrintAs[SymMult[AA_?xTensorQ,unprim_,prim_][BB_?xTensorQ]]^:=RowBox[{If[Not@AtomQ[AA],"(",""],PrintAs[AA],If[Not@AtomQ[AA],")",""],UnderoverscriptBox["\[CircleDot]",StringJoin[ToString[DisplayForm@NumOfUnprimedSlots[Spin]@BB,StandardForm],",",ToString[DisplayForm@NumOfPrimedSlots[Spin]@BB,StandardForm]],StringJoin[ToString[DisplayForm@unprim,StandardForm],",",ToString[DisplayForm@prim,StandardForm]]],If[Not@AtomQ[BB],"(",""],PrintAs[BB],If[Not@AtomQ[BB],")",""]}];


(* ::Input::Initialization:: *)
NumOfUnprimedSlots[Spin][SymMult[AA_?xTensorQ,unprim_,prim_][BB_?xTensorQ]]^:=NumOfUnprimedSlots[Spin][AA]+NumOfUnprimedSlots[Spin][BB]-2unprim;
NumOfPrimedSlots[Spin][SymMult[AA_?xTensorQ,unprim_,prim_][BB_?xTensorQ]]^:=NumOfPrimedSlots[Spin][AA]+NumOfPrimedSlots[Spin][BB]-2prim;


(* ::Input::Initialization:: *)
SymMult[expr_TensorPlus,unprim_,prim_][BB_]:=(SymMult[#1,unprim,prim][BB]&)/@expr;
SymMult[AA_,unprim_,prim_][expr_TensorPlus]:=(SymMult[AA,unprim,prim][#1]&)/@expr;
SymMult[ZeroTensor[vbs_],unprim_,prim_][BB_]:=ZeroTensor[SlotsOfTensor[SymMult[DummyTensor[vbs,CompatibleSymmetric[vbs]],unprim,prim][BB]]];
SymMult[AA_,unprim_,prim_][ZeroTensor[vbs_]]:=ZeroTensor[SlotsOfTensor[SymMult[AA,unprim,prim]@DummyTensor[vbs,CompatibleSymmetric[vbs]]]];
SymMult[MultScal[c_?ConstantQ,AA_?xTensorQ],unprim_,prim_][BB_]:=MultScal[c,SymMult[AA,unprim,prim][BB]];
SymMult[AA_,unprim_,prim_][MultScal[c_?ConstantQ,BB_?xTensorQ]]:=MultScal[c,SymMult[AA,unprim,prim][BB]];


(* ::Input::Initialization:: *)
SymMultMultScalRules={SymMult[MultScal[s_,AA_],unprim_,prim_][BB_]:>MultScal[s,SymMult[AA,unprim,prim][BB]],SymMult[AA_,unprim_,prim_][MultScal[s_,BB_]]:>MultScal[s,SymMult[AA,unprim,prim][BB]]};


(* ::Input::Initialization:: *)
Dagger[SymMult[AA_?xTensorQ,unprim_,prim_][BB_?xTensorQ]]^:=SymMult[If[HermitianQ[AA],AA,Dagger[AA]],prim,unprim][If[HermitianQ[BB],BB,Dagger[BB]]]


(* ::Input::Initialization:: *)
Dagger[SymMult[AA_?xTensorQ,unprim_,prim_][BB_?xTensorQ][inds__]]^:=PlaceIndicesInSpinor[Dagger[SymMult[AA,unprim,prim][BB]],DaggerIndex/@{inds},{Spin,Spin\[Dagger]}]


(* ::Input::Initialization:: *)
Tex[x:(SymMult[AA_?xTensorQ,unprim_,prim_][BB_?xTensorQ])]:=StringJoin[xAct`TexAct`Private`TexOpen["("],xAct`SymManipulator`Private`TexFundOp@x,xAct`TexAct`Private`TexClose[")"]];


(* ::Input::Initialization:: *)
xAct`SymManipulator`Private`TexFundOp[SymMult[AA_?xTensorQ,unprim_,prim_][BB_?xTensorQ]]:=StringJoin[xAct`TexAct`Private`TexFactor[AA],If[OptionValue[DefFundSpinOperators,ShowValenceInfo],StringJoin["\\underset{",Tex[NumOfUnprimedSlots[Spin][BB]/.ToOrderedPlus],",",Tex[NumOfPrimedSlots[Spin][BB]/.ToOrderedPlus],"}"],""],"{\\overset{",StringJoin[Tex[unprim/.ToOrderedPlus],",",Tex[prim/.ToOrderedPlus]],"}{\\odot }}",xAct`SymManipulator`Private`TexFundOp[BB]];


(* ::Input::Initialization:: *)
GHPComponentRulesOld[SymMult[AA_?xTensorQ,unprim_,prim_][BB_?xTensorQ],dyad_]:=GHPComponentRulesOld[SymMult[AA,unprim,prim][BB],dyad]=Module[{lhs=GiveIndicesToTensor[SymMult[AA,unprim,prim][BB]],rhs,spin=VBundleOfBasis@dyad},
(* Make sure the GHPWeights and Tex output are set by expanding into dyad *)
DyadExpansionEq[SymMult[AA,unprim,prim][BB],dyad];
If[$DyadCalcInfo,Print["Calculating the ",dyad,"components of ",lhs," in GHP form."]];
rhs=Expand[ExpandSym[lhs/.SymMultRule,SmartExpand->True]/.EqToRule@DyadExpansionEq[AA,dyad]/.GHPComponentRules[AA,dyad]];
If[Length[Select[SlotsOfTensor[BB],Or[UpIndex[#]===spin,UpIndex[#]===Dagger@spin]&]]>0,rhs=Expand[rhs/.EqToRule@DyadExpansionEq[BB,dyad]/.xAct`SpinFrames`Private`$GHPExtraDyadExpansions]];
Expand[Expand[DyadComponents[lhs==rhs]]/.GHPComponentRules[BB,dyad]//.$GHPExtraRules]/.Equal->Rule];


(* ::Input::Initialization:: *)
SpinorOfValenceQ[k_,l_][TT_]:=And[xTensorQ[TT],NumOfUnprimedSlots[Spin][TT]==k,NumOfPrimedSlots[Spin][TT]==l]


(* ::Input::Initialization:: *)
CommuteOp[SymMult[AA_?(SpinorOfValenceQ[1,1]),1,1],SymMult[AA_,0,1]]^:=SymMult[AA,1,1][SymMult[AA,0,1][TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
If[k>0,MultScal[k/(k+1),SymMult[AA,0,1][SymMult[AA,1,1][TT]]],ZeroTensor@SlotsOfTensor@SymMult[AA,1,1][SymMult[AA,0,1][TT]]]]/;EnoughIndsQSpin[TT,0,2];
CommuteOp[SymMult[AA_?(SpinorOfValenceQ[1,1]),0,1],SymMult[AA_,1,1]]^:=SymMult[AA,0,1][SymMult[AA,1,1][TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
MultScal[(k+1)/k,SymMult[AA,1,1][SymMult[AA,0,1][TT]]]]/;EnoughIndsQSpin[TT,1,2];CommuteOp[SymMult[AA_?(SpinorOfValenceQ[1,1]),1,1],SymMult[AA_,1,0]]^:=SymMult[AA,1,1][SymMult[AA,1,0][TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
If[l>0,MultScal[l/(l+1),SymMult[AA,1,0][SymMult[AA,1,1][TT]]],ZeroTensor@SlotsOfTensor@SymMult[AA,1,1][SymMult[AA,1,0][TT]]]]/;EnoughIndsQSpin[TT,2,0];
CommuteOp[SymMult[AA_?(SpinorOfValenceQ[1,1]),1,0],SymMult[AA_,1,1]]^:=SymMult[AA,1,0][SymMult[AA,1,1][TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
MultScal[(l+1)/l,SymMult[AA,1,1][SymMult[AA,1,0][TT]]]]/;EnoughIndsQSpin[TT,2,1];
CommuteOp[SymMult[AA_?(SpinorOfValenceQ[1,1]),0,1],SymMult[AA_,0,0]]^:=SymMult[AA,0,1][SymMult[AA,0,0][TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
If[l>0,MultScal[l/(l+1),SymMult[AA,0,0][SymMult[AA,0,1][TT]]],ZeroTensor@SlotsOfTensor@SymMult[AA,0,1][SymMult[AA,0,0][TT]]]];
CommuteOp[SymMult[AA_?(SpinorOfValenceQ[1,1]),1,0],SymMult[AA_,0,0]]^:=SymMult[AA,1,0][SymMult[AA,0,0][TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
If[k>0,MultScal[k/(k+1),SymMult[AA,0,0][SymMult[AA,1,0][TT]]],ZeroTensor@SlotsOfTensor@SymMult[AA,1,0][SymMult[AA,0,0][TT]]]];
CommuteOp[SymMult[AA_?(SpinorOfValenceQ[1,1]),0,0],SymMult[AA_,0,1]]^:=SymMult[AA,0,0][SymMult[AA,0,1][TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
MultScal[(l+1)/l,SymMult[AA,0,1][SymMult[AA,0,0][TT]]]]/;EnoughIndsQSpin[TT,0,1];
CommuteOp[SymMult[AA_?(SpinorOfValenceQ[1,1]),0,0],SymMult[AA_,1,0]]^:=SymMult[AA,0,0][SymMult[AA,1,0][TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
MultScal[(k+1)/k,SymMult[AA,1,0][SymMult[AA,0,0][TT]]]]/;EnoughIndsQSpin[TT,1,0];
CommuteOp[SymMult[AA_?(SpinorOfValenceQ[1,1]),0,1],SymMult[AA_,1,0],SymMult[AA_,1,0],SymMult[AA_,0,1]]^:=SymMult[AA,0,1][SymMult[AA,1,0][TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[SymMult[AA,1,0][SymMult[AA,0,1][TT]],MultScal[(1/(k+1)-1/(l+1)),SymMult[AA,0,0][SymMult[AA,1,1][TT]]]]]/;EnoughIndsQSpin[TT,1,1];
CommuteOp[SymMult[AA_?(SpinorOfValenceQ[1,1]),1,0],SymMult[AA_,0,1],SymMult[AA_,0,1],SymMult[AA_,1,0]]^:=SymMult[AA,1,0][SymMult[AA,0,1][TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[SymMult[AA,0,1][SymMult[AA,1,0][TT]],MultScal[(1/(l+1)-1/(k+1)),SymMult[AA,0,0][SymMult[AA,1,1][TT]]]]]/;EnoughIndsQSpin[TT,1,1];
CommuteOp[SymMult[AA_?(SpinorOfValenceQ[1,1]),1,1],SymMult[AA_,0,0],SymMult[AA_,0,1],SymMult[AA_,1,0]]^:=SymMult[AA,1,1][SymMult[AA,0,0][TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[MultScal[-(1/(k+1)+1/(l+1)),SymMult[AA,0,1][SymMult[AA,1,0][TT]]],If[l>0,MultScal[l*(l+2)/(l+1)^2,SymMult[AA,0,0][SymMult[AA,1,1][TT]]],ZeroTensor@SlotsOfTensor@SymMult[AA,1,1][SymMult[AA,0,0][TT]]]]]/;EnoughIndsQSpin[TT,1,0];
CommuteOp[SymMult[AA_?(SpinorOfValenceQ[1,1]),1,1],SymMult[AA_,0,0],SymMult[AA_,1,0],SymMult[AA_,0,1]]^:=SymMult[AA,1,1][SymMult[AA,0,0][TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[MultScal[-(1/(k+1)+1/(l+1)),SymMult[AA,1,0][SymMult[AA,0,1][TT]]],If[k>0,MultScal[k*(k+2)/(k+1)^2,SymMult[AA,0,0][SymMult[AA,1,1][TT]]],ZeroTensor@SlotsOfTensor@SymMult[AA,1,1][SymMult[AA,0,0][TT]]]]]/;EnoughIndsQSpin[TT,0,1];
CommuteOp[SymMult[AA_?(SpinorOfValenceQ[1,1]),0,0],SymMult[AA_,1,1],SymMult[AA_,0,1],SymMult[AA_,1,0]]^:=SymMult[AA,0,0][SymMult[AA,1,1][TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[MultScal[((1+l)*(2+k+l))/((1+k)*l*(2+l)),SymMult[AA,0,1][SymMult[AA,1,0][TT]]],MultScal[(1+l)^2/(l*(2+l)),SymMult[AA,1,1][SymMult[AA,0,0][TT]]]]]/;EnoughIndsQSpin[TT,1,1];
CommuteOp[SymMult[AA_?(SpinorOfValenceQ[1,1]),0,0],SymMult[AA_,1,1],SymMult[AA_,1,0],SymMult[AA_,0,1]]^:=SymMult[AA,0,0][SymMult[AA,1,1][TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[MultScal[((1+k)*(2+k+l))/((1+l)*k*(2+k)),SymMult[AA,1,0][SymMult[AA,0,1][TT]]],MultScal[(1+k)^2/(k*(2+k)),SymMult[AA,1,1][SymMult[AA,0,0][TT]]]]]/;EnoughIndsQSpin[TT,1,1];


(* ::Input::Initialization:: *)
AllSymMultCommutatorRules[AA_?(SpinorOfValenceQ[1,1])]:={CommuteOp[SymMult[AA,1,1],SymMult[AA,0,1]],CommuteOp[SymMult[AA,1,1],SymMult[AA,1,0]],CommuteOp[SymMult[AA,0,1],SymMult[AA,0,0]],CommuteOp[SymMult[AA,1,0],SymMult[AA,0,0]],CommuteOp[SymMult[AA,1,1],SymMult[AA,0,0],SymMult[AA,1,0],SymMult[AA,0,1]],CommuteOp[SymMult[AA,1,1],SymMult[AA,0,0],SymMult[AA,0,1],SymMult[AA,1,0]],CommuteOp[SymMult[AA,0,1],SymMult[AA,1,0],SymMult[AA,1,0],SymMult[AA,0,1]]};


(* ::Input::Initialization:: *)
CommuteOp[SymMult[AA_?(SpinorOfValenceQ[1,1]),i_,j_],SymMult[BB_?(SpinorOfValenceQ[1,1]),i_,j_]]^:=(SymMult[AA,i,j][SymMult[BB,i,j][TT_?xTensorQ]]:>SymMult[BB,i,j][SymMult[AA,i,j][TT]]/;AA=!=BB)


(* ::Input::Initialization:: *)
CommuteOp[SymMult[AA_?(SpinorOfValenceQ[1,1]),1,1],SymMult[BB_?(SpinorOfValenceQ[1,1]),0,1]]^:=(SymMult[AA,1,1][SymMult[BB,0,1][TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},TensorPlus[MultScal[-1/(k+1),SymMult[BB,1,1][SymMult[AA,0,1][TT]]],MultScal[k (k+2)/(k+1)^2,SymMult[BB,0,1][SymMult[AA,1,1][TT]]]]]/;AA=!=BB)
CommuteOp[SymMult[AA_?(SpinorOfValenceQ[1,1]),1,1],SymMult[BB_?(SpinorOfValenceQ[1,1]),1,0]]^:=(SymMult[AA,1,1][SymMult[BB,1,0][TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},TensorPlus[MultScal[-1/(l+1),SymMult[BB,1,1][SymMult[AA,1,0][TT]]],MultScal[l (l+2)/(l+1)^2,SymMult[BB,1,0][SymMult[AA,1,1][TT]]]]]/;AA=!=BB)


(* ::Input::Initialization:: *)
SymHToSymMultRule={x:SymH[{T1_,T2_ },group_,label_][inds___]:>Module[{dummybundles=VBundleOfIndex/@FindDummyIndices@Evaluate@x,symmultexpr,symmulteq,TFirst,TSecond},
{TFirst,TSecond}=SortBy[{T1,T2},Length@SlotsOfTensor@#&];
symmultexpr=GiveIndicesToTensor@SymMult[TFirst,NumOfUnprimedVBundles[Spin]@dummybundles,NumOfPrimedVBundles[Spin]@dummybundles][TSecond];
symmulteq=symmultexpr==ToCanonicalSym[symmultexpr/.SymMultRule];
x/.EqToCompareRule@FlipEquation@symmulteq
],x:(T1_?(And[xTensorQ[#],Not@MetricQ[#]&&Not[#===delta]]&)[indsa__]T2_?(And[xTensorQ[#],Not@MetricQ[#]&&Not[#===delta]]&)[indsb__]):> Module[{dummybundles=VBundleOfIndex/@FindDummyIndices@Evaluate@x,unprimed,primed,symmultexpr,symmulteq,TFirst,TSecond},
unprimed=NumOfUnprimedVBundles[Spin]@dummybundles;
primed=NumOfPrimedVBundles[Spin]@dummybundles;
{TFirst,TSecond}=SortBy[{T1,T2},Length@SlotsOfTensor@#&];
If[unprimed+primed==0,x,
symmultexpr=GiveIndicesToTensor@SymMult[TFirst,unprimed,primed][TSecond];
symmulteq=symmultexpr==ToCanonical[symmultexpr/.SymMultRule];
If[symmulteq===True,x,x/.EqToCompareRule@FlipEquation@symmulteq]
]]};


(* ::Input::Initialization:: *)
SymMultLeibnizRules={TwistCDe[SymMult[\[Phi]_?xTensorQ,m_,n_][\[CurlyPhi]_?xTensorQ]]:>With[{i=NumOfUnprimedSlots[Spin]@\[Phi],j=NumOfPrimedSlots[Spin]@\[Phi],k=NumOfUnprimedSlots[Spin]@\[CurlyPhi],l=NumOfPrimedSlots[Spin]@\[CurlyPhi]},
TensorPlus[
MultScal[(-1)^(m+n),SymMult[\[CurlyPhi],m,n]@TwistCDe[\[Phi]]],
MultScal[(-1)^(m+n)*n/(j+1),SymMult[\[CurlyPhi],m,n-1]@CurlCDe[\[Phi]]],
MultScal[(-1)^(m+n)*m/(i+1),SymMult[\[CurlyPhi],m-1,n]@CurlDgCDe[\[Phi]]],
MultScal[(-1)^(m+n)*m*n/(i+1)/(j+1),SymMult[\[CurlyPhi],m-1,n-1]@DivCDe[\[Phi]]],
SymMult[\[Phi],m,n]@TwistCDe[\[CurlyPhi]],
MultScal[n/(l+1),SymMult[\[Phi],m,n-1]@CurlCDe[\[CurlyPhi]]],
MultScal[m/(k+1),SymMult[\[Phi],m-1,n]@CurlDgCDe[\[CurlyPhi]]],
MultScal[m*n/(k+1)/(l+1),SymMult[\[Phi],m-1,n-1]@DivCDe[\[CurlyPhi]]]
]],
CurlCDe[SymMult[\[Phi]_?xTensorQ,m_,n_][\[CurlyPhi]_?xTensorQ]]:>With[{i=NumOfUnprimedSlots[Spin]@\[Phi],j=NumOfPrimedSlots[Spin]@\[Phi],k=NumOfUnprimedSlots[Spin]@\[CurlyPhi],l=NumOfPrimedSlots[Spin]@\[CurlyPhi]},
TensorPlus[
MultScal[-(-1)^(m+n)(l-n)/(j+l-2n),SymMult[\[CurlyPhi],m,n+1]@TwistCDe[\[Phi]]],
MultScal[(-1)^(m+n)*(j-n)(j+l-n+1)/(j+l-2n)/(j+1),SymMult[\[CurlyPhi],m,n]@CurlCDe[\[Phi]]],
MultScal[-(-1)^(m+n)*m*(l-n)/(j+l-2n)/(i+1),SymMult[\[CurlyPhi],m-1,n+1]@CurlDgCDe[\[Phi]]],
MultScal[(-1)^(m+n)*m*(j-n)(j+l-n+1)/(j+l-2n)/(i+1)/(j+1),SymMult[\[CurlyPhi],m-1,n]@DivCDe[\[Phi]]],
MultScal[-(j-n)/(j+l-2n),SymMult[\[Phi],m,n+1]@TwistCDe[\[CurlyPhi]]],
MultScal[(l-n)(j+l-n+1)/(j+l-2n)/(l+1),SymMult[\[Phi],m,n]@CurlCDe[\[CurlyPhi]]],
MultScal[-m*(j-n)/(j+l-2n)/(k+1),SymMult[\[Phi],m-1,n+1]@CurlDgCDe[\[CurlyPhi]]],
MultScal[m*(l-n)(j+l-n+1)/(j+l-2n)/(k+1)/(l+1),SymMult[\[Phi],m-1,n]@DivCDe[\[CurlyPhi]]]
]],
CurlDgCDe[SymMult[\[Phi]_?xTensorQ,m_,n_][\[CurlyPhi]_?xTensorQ]]:>With[{i=NumOfUnprimedSlots[Spin]@\[Phi],j=NumOfPrimedSlots[Spin]@\[Phi],k=NumOfUnprimedSlots[Spin]@\[CurlyPhi],l=NumOfPrimedSlots[Spin]@\[CurlyPhi]},
TensorPlus[
MultScal[-(-1)^(m+n)(k-m)/(i+k-2m),SymMult[\[CurlyPhi],m+1,n]@TwistCDe[\[Phi]]],
MultScal[-(-1)^(m+n)*n*(k-m)/(i+k-2m)/(j+1),SymMult[\[CurlyPhi],m+1,n-1]@CurlCDe[\[Phi]]],
MultScal[(-1)^(m+n)*(i-m)(i+k-m+1)/(i+k-2m)/(i+1),SymMult[\[CurlyPhi],m,n]@CurlDgCDe[\[Phi]]],
MultScal[(-1)^(m+n)*n*(i-m)(i+k-m+1)/(i+k-2m)/(i+1)/(j+1),SymMult[\[CurlyPhi],m,n-1]@DivCDe[\[Phi]]],
MultScal[-(i-m)/(i+k-2m),SymMult[\[Phi],m+1,n]@TwistCDe[\[CurlyPhi]]],
MultScal[-n*(i-m)/(i+k-2m)/(l+1),SymMult[\[Phi],m+1,n-1]@CurlCDe[\[CurlyPhi]]],
MultScal[(k-m)(i+k-m+1)/(i+k-2m)/(k+1),SymMult[\[Phi],m,n]@CurlDgCDe[\[CurlyPhi]]],
MultScal[n*(k-m)(i+k-m+1)/(i+k-2m)/(k+1)/(l+1),SymMult[\[Phi],m,n-1]@DivCDe[\[CurlyPhi]]]
]],
DivCDe[SymMult[\[Phi]_?xTensorQ,m_,n_][\[CurlyPhi]_?xTensorQ]]:>With[{i=NumOfUnprimedSlots[Spin]@\[Phi],j=NumOfPrimedSlots[Spin]@\[Phi],k=NumOfUnprimedSlots[Spin]@\[CurlyPhi],l=NumOfPrimedSlots[Spin]@\[CurlyPhi]},
TensorPlus[
MultScal[(-1)^(m+n)(k-m)(l-n)/(i+k-2m)/(j+l-2n),SymMult[\[CurlyPhi],m+1,n+1]@TwistCDe[\[Phi]]],
MultScal[-(-1)^(m+n)(k-m)(j-n)(j+l-n+1)/(i+k-2m)/(j+l-2n)/(j+1),SymMult[\[CurlyPhi],m+1,n]@CurlCDe[\[Phi]]],
MultScal[-(-1)^(m+n)(l-n)(i-m)(i+k-m+1)/(i+k-2m)/(j+l-2n)/(i+1),SymMult[\[CurlyPhi],m,n+1]@CurlDgCDe[\[Phi]]],
MultScal[(-1)^(m+n)(i-m)(j-n)(i+k-m+1)(j+l-n+1)/(i+k-2m)/(j+l-2n)/(i+1)/(j+1),SymMult[\[CurlyPhi],m,n]@DivCDe[\[Phi]]],
MultScal[(i-m)(j-n)/(i+k-2m)/(j+l-2n),SymMult[\[Phi],m+1,n+1]@TwistCDe[\[CurlyPhi]]],
MultScal[-(i-m)(l-n)(j+l-n+1)/(i+k-2m)/(j+l-2n)/(l+1),SymMult[\[Phi],m+1,n]@CurlCDe[\[CurlyPhi]]],
MultScal[-(k-m)(j-n)(i+k-m+1)/(i+k-2m)/(j+l-2n)/(k+1),SymMult[\[Phi],m,n+1]@CurlDgCDe[\[CurlyPhi]]],
MultScal[(k-m)(l-n)(i+k-m+1)(j+l-n+1)/(i+k-2m)/(j+l-2n)/(k+1)/(l+1),SymMult[\[Phi],m,n]@DivCDe[\[CurlyPhi]]]
]]};


(* ::Input::Initialization:: *)
TwistMultScal[(T_?xTensorQ)[]]:=TwistCDe[T]
TwistMultScal[Times[a_,rest__]]:=TensorPlus[MultScal[Times[rest],TwistMultScal[a]],MultScal[a,TwistMultScal[Times[rest]]]]
TwistMultScal[Power[a_,c_?ConstantQ]]:=MultScal[c*Power[a,c-1],TwistMultScal[a]]
TwistMultScal[expr_Plus]:=TwistMultScal/@TensorPlus@@expr
TwistMultScal[c_?ConstantQ]:=ZeroTensor[{-Spin,-Spin\[Dagger]}]


(* ::Input::Initialization:: *)
MultScalLeibnizRules={DivCDe[MultScal[expr_,T_]]:>TensorPlus[MultScal[expr,DivCDe[T]],SymMult[TwistMultScal[expr],1,1][T]],CurlCDe[MultScal[expr_,T_]]:>TensorPlus[MultScal[expr,CurlCDe[T]],SymMult[TwistMultScal[expr],0,1][T]],CurlDgCDe[MultScal[expr_,T_]]:>TensorPlus[MultScal[expr,CurlDgCDe[T]],SymMult[TwistMultScal[expr],1,0][T]],TwistCDe[MultScal[expr_,T_]]:>TensorPlus[MultScal[expr,TwistCDe[T]],SymMult[TwistMultScal[expr],0,0][T]]};


(* ::Input::Initialization:: *)
SymMultLeibnizEq[expr_]:=expr==(expr/.SymMultLeibnizRules//.MultScalRule)


(* ::Input::Initialization:: *)
DefaultSortSymMultFunc={NumOfUnprimedSlots[Spin][#]+NumOfPrimedSlots[Spin][#],NumOfUnprimedSlots[Spin][#],NumOfPrimedSlots[Spin][#]}&


(* ::Input::Initialization:: *)
SortSymMult[orderingfunc_:DefaultSortSymMultFunc]:={SymMult[\[Phi]_?xTensorQ,m_,n_][\[CurlyPhi]_?xTensorQ]:>MultScal[(-1)^(m+n),SymMult[\[CurlyPhi],m,n][\[Phi]]]/;Not[OrderedQ[orderingfunc/@{\[Phi],\[CurlyPhi]}]],SymMult[\[Phi]_?xTensorQ,m_,n_][\[Phi]_?xTensorQ]:>ZeroTensorFromSymmetricSpinor@SymMult[\[Phi],m,n][\[Phi]]/;((-1)^(m+n)==-1)}


(* ::Input::Initialization:: *)
SortSymMultReverse[orderingfunc_:DefaultSortSymMultFunc]:={SymMult[\[Phi]_?xTensorQ,m_,n_][\[CurlyPhi]_?xTensorQ]:>MultScal[(-1)^(m+n),SymMult[\[CurlyPhi],m,n][\[Phi]]]/;OrderedQ[orderingfunc/@{\[Phi],\[CurlyPhi]}],SymMult[\[Phi]_?xTensorQ,m_,n_][\[Phi]_?xTensorQ]:>ZeroTensorFromSymmetricSpinor@SymMult[\[Phi],m,n][\[Phi]]/;((-1)^(m+n)==-1)}


(* ::Input::Initialization:: *)
SymMultToMultScalRule=SymMult[\[Phi]_?xTensorQ,0,0][\[CurlyPhi]_?xTensorQ]:>MultScal[\[Phi][],\[CurlyPhi]]/;NumOfUnprimedSlots[Spin][\[Phi]]+NumOfPrimedSlots[Spin][\[Phi]]==0;


(* ::Input::Initialization:: *)
MultScalToSymMultRule=MultScal[(\[Phi]_?xTensorQ)[],\[CurlyPhi]_?xTensorQ]:>SymMult[\[Phi],0,0][\[CurlyPhi]];


(* ::Input::Initialization:: *)
ProductSymmetric[Ainds_,Binds_,ADginds_,BDginds_]:=Module[{VBundles,SGSlist},
(* Compute the strong generating sets for the separate symmetries *)
VBundles=Select[First@First@Position[IndexList[Sequence@@Ainds,Sequence@@Binds,Sequence@@ADginds,Sequence@@BDginds],#,1]&/@#&/@{Ainds,Binds,ADginds,BDginds},(Length[#]>=2)&];
If[Length@VBundles==1,SGSlist=Symmetric/@VBundles,
SGSlist=Symmetric[#,Cycles]&/@VBundles;
(* Join the symmetries *)
While[Length[SGSlist]>=2,
SGSlist[[2]]=JoinSGS[SGSlist[[1]],SGSlist[[2]]];
SGSlist=Delete[SGSlist,1];
];];
(* Return the remaining SGS or the trivial SGS if the list is empty. *)
If[Length[SGSlist]==1,First@SGSlist,StrongGenSet[{}, GenSet[]]]
]


(* ::Input::Initialization:: *)
IrrDecomposeSymMult[\[Phi]_?xTensorQ,\[CurlyPhi]_?xTensorQ,{p_,q_}]:=Module[{k,l,i,j,allinds,Ainds,Binds,Cinds,ADginds,BDginds,CDginds},
{i,j}=ValenceNumbersOfSpinor[\[Phi],Spin];
{k,l}=ValenceNumbersOfSpinor[\[CurlyPhi],Spin];
allinds=List@@GiveIndicesToTensor@SymMult[\[Phi],0,0][\[CurlyPhi]];
Ainds=Take[allinds,i-p];
Binds=Take[Drop[allinds,i-p],k-p];
Cinds=Take[Drop[allinds,i+k-2p],p];
ADginds=Take[Drop[allinds,i+k],j-q];
BDginds=Take[Drop[allinds,i+k+j-q],l-q];
CDginds=Take[Drop[allinds,i+k+j+l-2q],q];
PlaceIndicesInSpinor[\[Phi],Join[Ainds,ChangeIndex/@Cinds,ADginds,ChangeIndex/@CDginds],{Spin,Spin\[Dagger]}]PlaceIndicesInSpinor[\[CurlyPhi],Join[Binds,Cinds,BDginds,CDginds],{Spin,Spin\[Dagger]}]==(-1)^(p+q)Sum[(-1)^(m+n)Binomial[i-p,m-p]Binomial[k-p,m-p]Binomial[j-q,n-q]Binomial[l-q,n-q]/Binomial[i+k-m-p+1,m-p]/Binomial[j+l-n-q+1,n-q]*ImposeSym[Product[\[Epsilon][Ainds[[r]],Binds[[r]]],{r,1,m-p}]*Product[\[Epsilon]\[Dagger][ADginds[[r]],BDginds[[r]]],{r,1,n-q}]*PlaceIndicesInSpinor[SymMult[\[Phi],m,n][\[CurlyPhi]],Flatten@{Drop[Ainds,m-p],Drop[Binds,m-p],Drop[ADginds,n-q],Drop[BDginds,n-q]},{Spin,Spin\[Dagger]}],IndexList@@Flatten@{Ainds,Binds,ADginds,BDginds},ProductSymmetric[Ainds,Binds,ADginds,BDginds]],{m,p,Min[i,k]},{n,q,Min[j,l]}]
]/;And[CompatibleSymQ[SlotsOfTensor@\[Phi],SymmetryGroupOfTensor@\[Phi]],CompatibleSymQ[SlotsOfTensor@\[CurlyPhi],SymmetryGroupOfTensor@\[CurlyPhi]]]


(* ::Input::Initialization:: *)
SymMultCoeffFunc[i_,r_,k_,t_,mm_,MM_]:=Sum[Sum[((-1)^(-p+t+v)*Binomial[k-mm,p]*Binomial[mm,MM-p-v]*Binomial[k-mm-p,v]*Binomial[-mm+r,-p+t]*Binomial[i-t,MM-p-v]*Binomial[-p+t,v])/(Binomial[1+i+k-MM-p,MM-p]*Binomial[MM-p,v]*Binomial[k-2*mm+r,t]),{v,Max[0,MM-mm-p,MM+t-i-p],Min[MM-p,k-mm-p,t-p]}],{p,Max[0,mm-r+t],Min[k-mm,MM,t]}];


(* ::Input::Initialization:: *)
CommuteSymMultRuleOut[\[Omega]_?xTensorQ,AllowSame_:False]:={SymMult[\[Phi]_?xTensorQ,t_,u_][SymMult[\[Omega],m_,n_][\[CurlyPhi]_?xTensorQ]]:>Module[{i=NumOfUnprimedSlots[Spin]@\[Phi],j=NumOfPrimedSlots[Spin]@\[Phi],k=NumOfUnprimedSlots[Spin]@\[CurlyPhi],l=NumOfPrimedSlots[Spin]@\[CurlyPhi],r=NumOfUnprimedSlots[Spin]@\[Omega],s=NumOfPrimedSlots[Spin]@\[Omega]},
TensorPlus@@Flatten@Table[MultScal[SymMultCoeffFunc[i,r,k,t,m,M]SymMultCoeffFunc[j,s,l,u,n,NN],SymMult[\[Omega],t+m-M,u+n-NN][SymMult[\[Phi],M,NN][\[CurlyPhi]]]],{M,Max[0,t+m-r],Min[i,k]},{NN,Max[0,u+n-s],Min[j,l]}]]/;(Or[AllowSame,\[Phi]=!=\[Omega]]),SymMult[SymMult[\[Omega],m_,n_][\[CurlyPhi]_?xTensorQ],t_,u_][\[Phi]_?xTensorQ]:>Module[{i=NumOfUnprimedSlots[Spin]@\[Phi],j=NumOfPrimedSlots[Spin]@\[Phi],k=NumOfUnprimedSlots[Spin]@\[CurlyPhi],l=NumOfPrimedSlots[Spin]@\[CurlyPhi],r=NumOfUnprimedSlots[Spin]@\[Omega],s=NumOfPrimedSlots[Spin]@\[Omega]},
TensorPlus@@Flatten@Table[MultScal[(-1)^(t+u)*SymMultCoeffFunc[i,r,k,t,m,M]SymMultCoeffFunc[j,s,l,u,n,NN],SymMult[\[Omega],t+m-M,u+n-NN][SymMult[\[Phi],M,NN][\[CurlyPhi]]]],{M,Max[0,t+m-r],Min[i,k]},{NN,Max[0,u+n-s],Min[j,l]}]]/;(Or[AllowSame,\[Phi]=!=\[Omega]])}


(* ::Input::Initialization:: *)
CommuteSymMultRuleIn[\[Phi]_?xTensorQ]:=SymMult[\[Phi],t_,u_][SymMult[\[Omega]_?xTensorQ,m_,n_][\[CurlyPhi]_?xTensorQ]]:>Module[{i=NumOfUnprimedSlots[Spin]@\[Phi],j=NumOfPrimedSlots[Spin]@\[Phi],k=NumOfUnprimedSlots[Spin]@\[CurlyPhi],l=NumOfPrimedSlots[Spin]@\[CurlyPhi],r=NumOfUnprimedSlots[Spin]@\[Omega],s=NumOfPrimedSlots[Spin]@\[Omega]},
TensorPlus@@Flatten@Table[MultScal[SymMultCoeffFunc[i,r,k,t,m,M]SymMultCoeffFunc[j,s,l,u,n,NN],SymMult[\[Omega],t+m-M,u+n-NN][SymMult[\[Phi],M,NN][\[CurlyPhi]]]],{M,0,Min[i,k]},{NN,0,Min[j,l]}]]


(* ::Input::Initialization:: *)
CoeffFromMultScal[MultScal[c_?ConstantQ,T_]]:=c;
CoeffFromMultScal[_]:=1;


(* ::Input::Initialization:: *)
IsolateTensorPlus[eq_Equal,i_:1]:=Module[{tmpexpr=TensorPlus[eq[[1]],MultScal[-1,eq[[2]]]]},
MultScal[1/CoeffFromMultScal[tmpexpr[[i]]],tmpexpr[[i]]]==MultScal[-1/CoeffFromMultScal[tmpexpr[[i]]],Delete[tmpexpr,{i}]]]


(* ::Input::Initialization:: *)
CommuteSymMultRuleOutSame[\[Omega]_?xTensorQ]:=SymMult[\[Omega],t_,u_][SymMult[\[Omega],m_,n_][\[CurlyPhi]_?xTensorQ]]:>Module[{k=NumOfUnprimedSlots[Spin]@\[CurlyPhi],l=NumOfPrimedSlots[Spin]@\[CurlyPhi],r=NumOfUnprimedSlots[Spin]@\[Omega],s=NumOfPrimedSlots[Spin]@\[Omega]},
TensorPlus@@Flatten@Table[MultScal[SymMultCoeffFunc[r,r,k,t,m,M]SymMultCoeffFunc[s,s,l,u,n,NN],SymMult[\[Omega],t+m-M,u+n-NN][SymMult[\[Omega],M,NN][\[CurlyPhi]]]],{M,Max[0,t+m-r],Min[r,k]},{NN,Max[0,u+n-s],Min[s,l]}]]


(* ::Input::Initialization:: *)
CommuteSymMultRuleOutSameAdv[\[Omega]_?xTensorQ]:=SymMult[\[Omega],t_,u_][SymMult[\[Omega],m_,n_][\[CurlyPhi]_?xTensorQ]]:>Module[{tmpeq1=SymMult[\[Omega],t,u][SymMult[\[Omega],m,n][\[CurlyPhi]]]==(SymMult[\[Omega],t,u][SymMult[\[Omega],m,n][\[CurlyPhi]]]/.CommuteSymMultRuleOutSame[\[Omega]]),tmpeq2},If[tmpeq1===True,SymMult[\[Omega],t,u][SymMult[\[Omega],m,n][\[CurlyPhi]]],
tmpeq2=IsolateTensorPlus[tmpeq1];If[SymMult[\[Omega],t,u][SymMult[\[Omega],m,n][\[CurlyPhi]]]===tmpeq2[[1]],tmpeq2[[2]],SymMult[\[Omega],t,u][SymMult[\[Omega],m,n][\[CurlyPhi]]]]]]


(* ::Input::Initialization:: *)
CommuteOp[DivCDe,CurlCDe]^=DivCDe[CurlCDe[TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[
MultScal[k/(k+1),CurlCDe[DivCDe[TT]]],
MultScal[(l-2),SymMult[PsiCDe\[Dagger],0,3][TT]],
MultScal[k,SymMult[PhiCDe,1,2][TT]]
]]/;EnoughIndsQSpin[TT,0,2];
CommuteOp[CurlCDe,DivCDe]^=CurlCDe[DivCDe[TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[
MultScal[(k+1)/k,DivCDe[CurlCDe[TT]]],
MultScal[-(l-2)(k+1)/k,SymMult[PsiCDe\[Dagger],0,3][TT]],
MultScal[-(k+1),SymMult[PhiCDe,1,2][TT]]
]]/;EnoughIndsQSpin[TT,1,2];
CommuteOp[DivCDe,CurlDgCDe]^=DivCDe[CurlDgCDe[TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[
MultScal[l/(l+1),CurlDgCDe[DivCDe[TT]]],
MultScal[(k-2),SymMult[PsiCDe,3,0][TT]],
MultScal[l,SymMult[PhiCDe,2,1][TT]]
]]/;EnoughIndsQSpin[TT,2,0];
CommuteOp[CurlDgCDe,DivCDe]^=CurlDgCDe[DivCDe[TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[
MultScal[(l+1)/l,DivCDe[CurlDgCDe[TT]]],
MultScal[-(k-2)(l+1)/l,SymMult[PsiCDe,3,0][TT]],
MultScal[-(l+1),SymMult[PhiCDe,2,1][TT]]
]]/;EnoughIndsQSpin[TT,2,1];
CommuteOp[CurlCDe,TwistCDe]^=CurlCDe[TwistCDe[TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[
MultScal[l/(l+1),TwistCDe[CurlCDe[TT]]],
MultScal[k,SymMult[PsiCDe,1,0][TT]],
MultScal[l,SymMult[PhiCDe,0,1][TT]]
]]/;EnoughIndsQSpin[TT,0,0];
CommuteOp[TwistCDe,CurlCDe]^=TwistCDe[CurlCDe[TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[
MultScal[(l+1)/l,CurlCDe[TwistCDe[TT]]],
MultScal[-k(l+1)/l,SymMult[PsiCDe,1,0][TT]],
MultScal[-(l+1),SymMult[PhiCDe,0,1][TT]]
]]/;EnoughIndsQSpin[TT,0,1];
CommuteOp[CurlDgCDe,TwistCDe]^=CurlDgCDe[TwistCDe[TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[
MultScal[k/(k+1),TwistCDe[CurlDgCDe[TT]]],
MultScal[l,SymMult[PsiCDe\[Dagger],0,1][TT]],
MultScal[k,SymMult[PhiCDe,1,0][TT]]
]]/;EnoughIndsQSpin[TT,0,0];
CommuteOp[TwistCDe,CurlDgCDe]^=TwistCDe[CurlDgCDe[TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[
MultScal[(k+1)/k,CurlDgCDe[TwistCDe[TT]]],
MultScal[-l(k+1)/k,SymMult[PsiCDe\[Dagger],0,1][TT]],
MultScal[-(k+1),SymMult[PhiCDe,1,0][TT]]
]]/;EnoughIndsQSpin[TT,1,0];
CommuteOp[DivCDe,TwistCDe,CurlCDe,CurlDgCDe]^=DivCDe[TwistCDe[TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[
MultScal[-(1/(k+1)+1/(l+1)),CurlCDe[CurlDgCDe[TT]]],
MultScal[l*(l+2)/(l+1)^2,TwistCDe[DivCDe[TT]]],
MultScal[(l+2)(k-1)/(l+1),SymMult[PsiCDe,2,0][TT]],
MultScal[(l+2)l/(l+1),SymMult[PhiCDe,1,1][TT]],
MultScal[-(l+2)(k+2)/(l+1),SymMult[LambdaCDe,0,0][TT]],
MultScal[ l (l-1)/(l+1),SymMult[PsiCDe\[Dagger],0,2][TT]],
MultScal[ l k/(l+1),SymMult[PhiCDe,1,1][TT]],
MultScal[- l(l+2)/(l+1),SymMult[LambdaCDe,0,0][TT]]
]]/;EnoughIndsQSpin[TT,1,0];
CommuteOp[TwistCDe,DivCDe,CurlCDe,CurlDgCDe]^=TwistCDe[DivCDe[TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[
MultScal[((1+l)*(2+k+l))/((1+k)*l*(2+l)),CurlCDe[CurlDgCDe[TT]]],
MultScal[(1+l)^2/(l*(2+l)),DivCDe[TwistCDe[TT]]],
MultScal[-(k-1) (1+l)/l,SymMult[PsiCDe,2,0][TT]],
MultScal[-l(1+l)/l,SymMult[PhiCDe,1,1][TT]],
MultScal[(k+2)(1+l)/l,SymMult[LambdaCDe,0,0][TT]],
MultScal[-l(l-1)(1+l)/(l*(2+l)),SymMult[PsiCDe\[Dagger],0,2][TT]],
MultScal[-k(1+l)/(2+l),SymMult[PhiCDe,1,1][TT]],
MultScal[l+1,SymMult[LambdaCDe,0,0][TT]]
]]/;EnoughIndsQSpin[TT,1,1];
CommuteOp[DivCDe,TwistCDe,CurlDgCDe,CurlCDe]^=DivCDe[TwistCDe[TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[
MultScal[-(1/(k+1)+1/(l+1)),CurlDgCDe[CurlCDe[TT]]],
MultScal[k*(k+2)/(k+1)^2,TwistCDe[DivCDe[TT]]],
MultScal[(k+2)(l-1)/(k+1),SymMult[PsiCDe\[Dagger],0,2][TT]],
MultScal[(k+2)k/(k+1),SymMult[PhiCDe,1,1][TT]],
MultScal[-(k+2)(l+2)/(k+1),SymMult[LambdaCDe,0,0][TT]],
MultScal[k (k-1)/(k+1),SymMult[PsiCDe,2,0][TT]],
MultScal[l k/(k+1),SymMult[PhiCDe,1,1][TT]],
MultScal[-k(k+2)/(k+1),SymMult[LambdaCDe,0,0][TT]]
]]/;EnoughIndsQSpin[TT,0,1];
CommuteOp[TwistCDe,DivCDe,CurlDgCDe,CurlCDe]^=TwistCDe[DivCDe[TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[
MultScal[((1+k)*(2+k+l))/((1+l)*k*(2+k)),CurlDgCDe[CurlCDe[TT]]],
MultScal[(1+k)^2/(k*(2+k)),DivCDe[TwistCDe[TT]]],
MultScal[-(l-1)(1+k)/k,SymMult[PsiCDe\[Dagger],0,2][TT]],
MultScal[-(1+k),SymMult[PhiCDe,1,1][TT]],
MultScal[(l+2)(1+k)/k,SymMult[LambdaCDe,0,0][TT]],
MultScal[-(k-1)(1+k)/(2+k),SymMult[PsiCDe,2,0][TT]],
MultScal[-l (1+k)/(2+k),SymMult[PhiCDe,1,1][TT]],
MultScal[(1+k),SymMult[LambdaCDe,0,0][TT]]
]]/;EnoughIndsQSpin[TT,1,1];
CommuteOp[CurlCDe,CurlDgCDe,CurlDgCDe,CurlCDe]^=CurlCDe[CurlDgCDe[TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[
CurlDgCDe[CurlCDe[TT]],
MultScal[(1/(k+1)-1/(l+1)),TwistCDe[DivCDe[TT]]],
MultScal[(k-1),SymMult[PsiCDe,2,0][TT]],
MultScal[l,SymMult[PhiCDe,1,1][TT]],
MultScal[-(k+2),SymMult[LambdaCDe,0,0][TT]],
MultScal[-(l-1),SymMult[PsiCDe\[Dagger],0,2][TT]],
MultScal[ -k,SymMult[PhiCDe,1,1][TT]],
MultScal[(l+2),SymMult[LambdaCDe,0,0][TT]]
]]/;EnoughIndsQSpin[TT,1,1];
CommuteOp[CurlDgCDe,CurlCDe,CurlCDe,CurlDgCDe]^=CurlDgCDe[CurlCDe[TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[
CurlCDe[CurlDgCDe[TT]],
MultScal[(1/(l+1)-1/(k+1)),TwistCDe[DivCDe[TT]]],
MultScal[-(k-1),SymMult[PsiCDe,2,0][TT]],
MultScal[-l,SymMult[PhiCDe,1,1][TT]],
MultScal[(k+2),SymMult[LambdaCDe,0,0][TT]],
MultScal[(l-1),SymMult[PsiCDe\[Dagger],0,2][TT]],
MultScal[k,SymMult[PhiCDe,1,1][TT]],
MultScal[-(l+2),SymMult[LambdaCDe,0,0][TT]]
]]/;EnoughIndsQSpin[TT,1,1];
CommuteOp[CurlDgCDe,CurlCDe,DivCDe,TwistCDe]^=CurlDgCDe[CurlCDe[TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[MultScal[-(((1+k) (1+l))/(2+k+l)),DivCDe[TwistCDe[TT]]],
MultScal[(k (2+k) (1+l))/((1+k) (2+k+l)),TwistCDe[DivCDe[TT]]],
MultScal[((2+k) (-1+l) (1+l))/(2+k+l),SymMult[PsiCDe\[Dagger],0,2][TT]],
MultScal[(k (2+k) (1+l))/(2+k+l),SymMult[PhiCDe,1,1][TT]],
MultScal[-(((2+k) (1+l) (2+l))/(2+k+l)),SymMult[LambdaCDe,0,0][TT]],
MultScal[((-1+k) k (1+l))/(2+k+l),SymMult[PsiCDe,2,0][TT]],
MultScal[(k l (1+l))/(2+k+l),SymMult[PhiCDe,1,1][TT]],
MultScal[-((k (2+k) (1+l))/(2+k+l)),SymMult[LambdaCDe,0,0][TT]]
]]/;EnoughIndsQSpin[TT,0,1];
CommuteOp[CurlCDe,CurlDgCDe,DivCDe,TwistCDe]^=CurlCDe[CurlDgCDe[TT_?xTensorQ]]:>With[{k=NumOfUnprimedSlots[Spin]@TT,l=NumOfPrimedSlots[Spin]@TT},
TensorPlus[MultScal[-(((1+k) (1+l))/(2+k+l)),DivCDe[TwistCDe[TT]]],
MultScal[((1+k) l (2+l))/((1+l) (2+k+l)),TwistCDe[DivCDe[TT]]],
MultScal[((-1+k) (1+k) (2+l))/(2+k+l),SymMult[PsiCDe,2,0][TT]],
MultScal[((1+k) l (2+l))/(2+k+l),SymMult[PhiCDe,1,1][TT]],
MultScal[-(((1+k) (2+k) (2+l))/(2+k+l)),SymMult[LambdaCDe,0,0][TT]],
MultScal[((1+k) (-1+l) l)/(2+k+l),SymMult[PsiCDe\[Dagger],0,2][TT]],
MultScal[(k (1+k) l)/(2+k+l),SymMult[PhiCDe,1,1][TT]],
MultScal[-(((1+k) l (2+l))/(2+k+l)),SymMult[LambdaCDe,0,0][TT]]
]]/;EnoughIndsQSpin[TT,1,0];


(* ::Input::Initialization:: *)
Options[ComputeAdjoint]^={ResultType->"IntegralEquation"};


(* ::Input::Initialization:: *)
Options[ComputeAdjoint]^={ResultType->"IntegralEquation"};


(* ::Input::Initialization:: *)
ReadAdjoint[IntExpr[integrand1_,boundary1_],var_]:=ToCanonical@IndexCoefficient[integrand1,ChangeIndex/@GiveIndicesToTensor@var]


(* ::Input::Initialization:: *)
ComputeAdjoint[op1_,var_,adjvar_,options:OptionsPattern[]]:=Module[{freeinds=IndicesOf[Free,{Spin,Spin\[Dagger]}][op1],preint,res,adj},res=ComputeAdjoint1[preint=IntExpr[Expand[op1*adjvar@@(ChangeIndex/@freeinds)],0],var];
adj=ReadAdjoint[res,var];
Switch[OptionValue[ResultType],"IntegralEquation",preint==res,"Adjoint",adj,"Equation",If[xTensorQ[Head@op1],PlaceIndicesInSpinor[AdjointOp[Head@op1,var][adjvar],List@@IndicesOf[Free][adj],{Spin,Spin\[Dagger]}]==adj,Throw@Message[ComputeAdjoint::error,"ResultType equation can only be used on operators."]],_,res]]


(* ::Input::Initialization:: *)
ComputeAdjoint1[intexpr_,var_]:=ContractSumIntegral[Plus@@(ComputeAdjoint2[#,var]&/@xAct`xTensor`Private`ListOfTerms@ExpandSumIntegral@intexpr)]


(* ::Input::Initialization:: *)
ComputeAdjoint2[IntExpr[integrand1_,boundary1_],var_]:=With[{factors=Select[Select[xAct`xTensor`Private`ListOfFactors[integrand1],Not@FreeQ[#,var]&],Not[First@xAct`SymManipulator`Private`SpecialEqualExpressionsQ[#,GiveIndicesToTensor@var]]&]},If[Length@factors>=1,ComputeAdjoint1[ContractAndToCanonical@IntegrateByParts[IntExpr[integrand1,boundary1],factors],var],IntExpr[integrand1,boundary1]]]


(* ::Input::Initialization:: *)
xTensorQ[AdjointOp[op1_?xTensorQ,var_][adjvar_]]^=True;
SlotsOfTensor[AdjointOp[op1_?xTensorQ,var_][adjvar_]]^:=SlotsOfTensor[var];
SymmetryGroupOfTensor[AdjointOp[op1_?xTensorQ,var_][adjvar_]]^:=SymmetryGroupOfTensor[var];
PrintAs[AdjointOp[op1_?xTensorQ,var_][adjvar_]]^:=Module[{varprintas=PrintAs[var],opprint},PrintAs[var]^="";
opprint=PrintAs[op1];
PrintAs[var]^=varprintas;
RowBox[{"(",SuperscriptBox[RowBox[{"(",opprint,")"}],"\[Dagger]"],PrintAs[adjvar],")"}]]
Tex[AdjointOp[op1_?xTensorQ,var_][adjvar_]]^:=Module[{vartex=Tex[var],optex},Tex[var]^="";optex=Tex[op1];
Tex[var]^=vartex;
StringJoin[xAct`TexAct`Private`TexOpen["("],optex,"^{\\dagger}",Tex[adjvar],xAct`TexAct`Private`TexClose[")"]]]


(* ::Input::Initialization:: *)
xTensorQ[HermAdjOp[op1_?xTensorQ,var_][adjvar_]]^=True;
SlotsOfTensor[HermAdjOp[op1_?xTensorQ,var_][adjvar_]]^:=Join[Cases[#1,-Spin],Cases[#1,-Spin\[Dagger]]]&[DownIndex/@(SlotsOfTensor[Dagger@var])];
SymmetryGroupOfTensor[HermAdjOp[op1_?xTensorQ,var_][adjvar_]]^:=xAct`SymManipulator`Private`CompatibleSym@SlotsOfTensor[HermAdjOp[op1,var][adjvar]];
PrintAs[HermAdjOp[op1_?xTensorQ,var_][adjvar_]]^:=Module[{varprintas=PrintAs[var],opprint},PrintAs[var]^="";
opprint=PrintAs[op1];
PrintAs[var]^=varprintas;
RowBox[{"(",SuperscriptBox[RowBox[{"(",opprint,")"}],"\[Star]"],PrintAs[adjvar],")"}]];
Tex[HermAdjOp[op1_?xTensorQ,var_][adjvar_]]^:=Module[{vartex=Tex[var],optex},Tex[var]^="";optex=Tex[op1];
Tex[var]^=vartex;
StringJoin[xAct`TexAct`Private`TexOpen["("],optex,"^{\\star}",Tex[adjvar],xAct`TexAct`Private`TexClose[")"]]];
Dagger[AdjointOp[op1_?xTensorQ,var_][adjvar_]]^:=HermAdjOp[op1,var][Dagger@adjvar];
Dagger[AdjointOp[op1_?xTensorQ,var_][adjvar_][inds__]]^:=PlaceIndicesInSpinor[HermAdjOp[op1,var][Dagger@adjvar],DaggerIndex/@{inds},{Spin,Spin\[Dagger]}]


(* ::Input::Initialization:: *)
Dagger[HermAdjOp[op1_?xTensorQ,var_][adjvar_][inds__]]^:=PlaceIndicesInSpinor[AdjointOp[op1,var][Dagger@adjvar],DaggerIndex/@{inds},{Spin,Spin\[Dagger]}]
Dagger[HermAdjOp[op1_?xTensorQ,var_][adjvar_]]^:=AdjointOp[op1,var][Dagger@adjvar];


(* ::Input::Initialization:: *)
RemoveConstantFactors[c_?ConstantQ*expr_]:=expr;


(* ::Input::Initialization:: *)
RemoveConstantFactors[expr_]:=expr;


(* ::Input::Initialization:: *)
FindIrrDecParts[expr_]:=FindIrrDecParts[expr,{\[Epsilon],\[Epsilon]\[Dagger]}];


(* ::Input::Initialization:: *)
FindIrrDecParts[expr_,spinmetrics_]:=With[{vbPMQs=xAct`xTensor`Private`VBundleIndexPMQ/@VBundleOfMetric/@spinmetrics,termlist=xAct`xTensor`Private`ListOfTerms[expr]},
Union[ChangeFreeIndicesToDefault[RemoveConstantFactors[(#/.((#[A_,B_]->1)&/@spinmetrics)/.((delta[A_?#,B_?#]->1)&/@vbPMQs))],{Spin\[Dagger]}]&/@termlist]]


(* ::Input::Initialization:: *)
NameTensors1[struct_List,basename_String,baseprintas_String]:=If[Length@struct==1,{{Symbol[StringJoin[basename,ToString[struct[[1,1]]],ToString[struct[[1,2]]]]]@@Join[DownIndex/@GetIndexRange[struct[[1,1]],Spin],GetIndexRange[struct[[1,2]],Spin\[Dagger]]],struct[[1,3]],StringJoin["\!\(\*UnderscriptBox[\(",baseprintas,"\), \(",ToString[struct[[1,1]]],",", ToString[struct[[1,2]]],"\)]\)"],StringJoin["\\underset{",ToString[struct[[1,1]]],",", ToString[struct[[1,2]]],"}{",Tex[baseprintas],"}{}"]}},
{Symbol[StringJoin[basename,ToString[struct[[#,1]]],ToString[struct[[#,2]]],FromCharacterCode[96+#]]]@@Join[DownIndex/@GetIndexRange[struct[[#,1]],Spin],GetIndexRange[struct[[#,2]],Spin\[Dagger]]],struct[[#,3]],StringJoin["\!\(\*UnderscriptBox[\(",baseprintas,FromCharacterCode[96+#],"\), \(",ToString[struct[[#,1]]],",", ToString[struct[[#,2]]],"\)]\)"],StringJoin["\\underset{",ToString[struct[[#,1]]],",", ToString[struct[[#,2]]],"}{",Tex[baseprintas],FromCharacterCode[96+#],"}{}"]}&/@Range@Length@struct
]


(* ::Input::Initialization:: *)
GiveNamesToIrrDecParts[irrdectensors_List,basename_String,baseprintas_String]:=With[{NumOfUnprimedVBundles=Length@Cases[UpIndex/@#,Spin]&,
NumOfPrimedVBundles=Length@Cases[UpIndex/@#,Dagger[Spin]]&},
Module[{sortedtensors=
Sort[{NumOfUnprimedVBundles[VBundleOfIndex/@FindFreeIndices@#],NumOfPrimedVBundles[VBundleOfIndex/@FindFreeIndices@#],#}&/@irrdectensors],numberofkind},
Flatten[NameTensors1[#,basename,baseprintas]&/@GatherBy[sortedtensors,Most],1]
]]


(* ::Input::Initialization:: *)
DefIrrDecTensors[irrdectensors_List,basename_String,baseprintas_String]:=Module[{namestruct=GiveNamesToIrrDecParts[irrdectensors,basename,baseprintas],defcommands},defcommands={First[#],M4,CompatibleSymmetric[IndexList@@First[#]],PrintAs->#[[3]]}&/@namestruct;
DefSpinor@@@defcommands;
(Tex[Head[First[#]]]^=#[[4]])&/@namestruct;
Equal@@@(Take[#,2]&/@namestruct)]


(* ::Input::Initialization:: *)
TetradOfDyad::usage=""


(* ::Input::Initialization:: *)
TetradOfDyad[Dyad]^=NP;


(* ::Input::Initialization:: *)
DefConstantSymbol[NoComponent]


(* ::Input::Initialization:: *)
DyadComponentByNumberSymmetric[\[Phi]_?xTensorQ,{i_?IntegerQ,j_?IntegerQ},dyad_]:=Module[{k=NumOfUnprimedSlotsDyad[dyad]@\[Phi],l=NumOfPrimedSlotsDyad[dyad]@\[Phi]},If[i>k||j>l||i<0||j<0,NoComponent,PlaceIndicesInSpinor[\[Phi],Flatten[{ConstantArray[{0,-dyad},k-i],ConstantArray[{1,-dyad},i],ConstantArray[{0,-Dagger@dyad},l-j],ConstantArray[{1,-Dagger@dyad},j]},1],{Spin,Spin\[Dagger]}]]];


(* ::Input::Initialization:: *)
AllDyadComponentsSymmetric[T_?xTensorQ,dyad_]:=AllDyadComponentsSymmetric[T,dyad]^=Module[{k=NumOfUnprimedSlotsDyad[dyad][T],l=NumOfPrimedSlotsDyad[dyad][T]},Flatten@Table[PlaceIndicesInSpinor[T,Join[Table[{0,-dyad},k-i],Table[{1,-dyad},i],Table[{0,-Dagger@dyad},l-j],Table[{1,-Dagger@dyad},j]],{VBundleOfBasis[dyad],Dagger@VBundleOfBasis[dyad]}],{i,0,k},{j,0,l}]]


(* ::Input::Initialization:: *)
GHPWeightRulesSymmetric[SS_?xTensorQ,dyad_]:=AllDyadComponentsSymmetric[SS,dyad]/.TT_?xTensorQ[inds___]:>Module[{dyadinds=Select[{inds},#[[2]]===-dyad&],dyaddginds=Select[{inds},#[[2]]===-Dagger[dyad]&]},UpSet[GHPWeightOf[TT[inds]],{Length@dyadinds-2*(Plus@@(First/@dyadinds)),Length@dyaddginds-2*(Plus@@(First/@dyaddginds))}]];


(* ::Input::Initialization:: *)
FormatComponentsSymmetric[dyad_,SS_?xTensorQ,symbform_]:=(AllDyadComponentsSymmetric[SS,dyad]/.TT_?xTensorQ[inds___]:>Module[{dyadinds=Select[{inds},#[[2]]===-dyad&],dyaddginds=Select[{inds},#[[2]]===-Dagger[dyad]&]},UpSet[MakeBoxes[TT[inds],StandardForm],xAct`xTensor`Private`interpretbox[TT[inds],SubscriptBox[PrintAs[TT],StringJoin["",If[Length[dyadinds]>0,symbform@ToString[Plus@@(First/@dyadinds)],""],If[Length[dyaddginds]>0,StringJoin[symbform@ToString[Plus@@(First/@dyaddginds)],"'"],""],""]]]]]);


(* ::Input::Initialization:: *)
SetTexComponentsSymmetric[dyad_, SS_?xTensorQ, texform_]:=(AllDyadComponentsSymmetric[SS,dyad]/.TT_?xTensorQ[inds___]:>Module[{dyadinds=Select[{inds},#[[2]]===-dyad&],dyaddginds=Select[{inds},#[[2]]===-Dagger[dyad]&]},UpSet[Tex[TT[inds]],StringJoin[Tex[TT],"_{",If[Length[dyadinds]>0,texform@ToString[Plus@@(First/@dyadinds)],""],If[Length[dyaddginds]>0,StringJoin[texform@ToString[Plus@@(First/@dyaddginds)],"'"],""],"}"]]]);


(* ::Input::Initialization:: *)
SetGHPWeightAndFormatSymmetric[SS_?xTensorQ,dyad_]:=(SetGHPWeightAndFormatSymmetric[SS,dyad]^=Module[{},If[$DyadCalcInfo,Print["GHP weights for ",SS," components are generated, ",If[OptionValue[DyadExpansionEq,FormatComponents],"components are formatted, ",""],If[OptionValue[DyadExpansionEq,SetTexComponents],"Tex components are set.",""]]];
GHPWeightRulesSymmetric[SS,dyad];
If[OptionValue[DyadExpansionEq,FormatComponents],FormatComponentsSymmetric[dyad,SS,OptionValue[DefSpinDyad,SymbolFormattingFunction]]];
If[OptionValue[DyadExpansionEq,SetTexComponents],SetTexComponentsSymmetric[dyad,SS,OptionValue[DefSpinDyad,SymbolTexFunction]]];
If[Or[HermitianQ[SS]=!=True,AntihermitianQ[SS]=!=True],GHPWeightRulesSymmetric[Dagger@SS,dyad];If[OptionValue[DyadExpansionEq,FormatComponents],FormatComponentsSymmetric[dyad,Dagger@SS,OptionValue[DefSpinDyad,SymbolFormattingFunction]]];
If[OptionValue[DyadExpansionEq,SetTexComponents],SetTexComponentsSymmetric[dyad,Dagger@SS,OptionValue[DefSpinDyad,SymbolTexFunction]]];
];])


(* ::Input::Initialization:: *)
SetGHPWeightAndFormatSymmetric[PsiCDe,Dyad]^=Null;
SetGHPWeightAndFormatSymmetric[PsiCDe\[Dagger],Dyad]^=Null;
SetGHPWeightAndFormatSymmetric[PhiCDe,Dyad]^=Null;


(* ::Input::Initialization:: *)
DyadExpansionEq[T_?xTensorQ,dyad_,options:OptionsPattern[]]:=(DyadExpansionEq[T,dyad]^=Module[{X=GiveIndicesToTensor[T],k=NumOfUnprimedSlotsDyad[dyad][T],l=NumOfPrimedSlotsDyad[dyad][T],unprimedinds, primedinds,M},
SetGHPWeightAndFormatSymmetric[T,dyad];
If[$DyadCalcInfo,Print[T," is expanded into ", dyad]];
{unprimedinds, primedinds}=ExtractUnprimedAndPrimed[VBundleOfBasis@dyad][List@@X];
X==Expand[Sum[(-1)^(k-m+l-n)Binomial[k,m]Binomial[l,n]DyadComponentByNumberSymmetric[T,{m,n},dyad]ExpandSym[ImposeSym[Product[SpinorsOfDyad[dyad][[1]][unprimedinds[[M]]],{M,1,m}]Product[SpinorsOfDyad[dyad][[2]][unprimedinds[[M]]],{M,m+1,k}]],SmartExpand->True]ExpandSym[ImposeSym[Product[Dagger[SpinorsOfDyad[dyad][[1]]][primedinds[[M]]],{M,1,n}]Product[Dagger[SpinorsOfDyad[dyad][[2]]][primedinds[[M]]],{M,n+1,l}]],SmartExpand->True],{m,0,k},{n,0,l}]]]
)/;CompatibleSymQ[SlotsOfTensor[T],SymmetryGroupOfTensor@T,{VBundleOfBasis[dyad],Dagger@VBundleOfBasis[dyad]}]


(* ::Input::Initialization:: *)
GHPComponentRules[(op_?FundSpinOpQ)[TT_?xTensorQ,extr___],dyad_]=.


(* ::Input::Initialization:: *)
GHPComponentRules[TwistCDe[\[Phi]_?xTensorQ],dyad_]:=GHPComponentRules[TwistCDe[\[Phi]],dyad]=Module[{i,j,k=NumOfUnprimedSlotsDyad[dyad]@\[Phi],l=NumOfPrimedSlotsDyad[dyad]@\[Phi],\[Kappa]dyad=GHPSpinCoefficients[dyad][[1]],
\[Rho]dyad=GHPSpinCoefficients[dyad][[2]],
\[Sigma]dyad=GHPSpinCoefficients[dyad][[3]],
\[Tau]dyad=GHPSpinCoefficients[dyad][[4]],
\[Kappa]pdyad=GHPSpinCoefficients[dyad][[5]],
\[Rho]pdyad=GHPSpinCoefficients[dyad][[6]],
\[Sigma]pdyad=GHPSpinCoefficients[dyad][[7]],
\[Tau]pdyad=GHPSpinCoefficients[dyad][[8]],theta=SymbolJoin["\[CapitalTheta]",dyad],np=TetradOfDyad[dyad]},
SetGHPWeightAndFormatSymmetric[\[Phi],dyad];
SetGHPWeightAndFormatSymmetric[TwistCDe[\[Phi]],dyad];
If[$DyadCalcInfo,Print["Calculating the ",dyad,"components of ",TwistCDe[\[Phi]]," in GHP form. (Improved code)"]];
Expand[Expand[Flatten[Table[Table[DyadComponentByNumberSymmetric[TwistCDe[\[Phi]],{i,j},dyad]->1/((k+1) (l+1))*(
(k-i+1)(l-j+1)(theta[{1,-np}][DyadComponentByNumberSymmetric[\[Phi],{i,j},dyad]]+i*\[Rho]dyad*DyadComponentByNumberSymmetric[\[Phi],{i,j},dyad] + j*Dagger[\[Rho]dyad]*DyadComponentByNumberSymmetric[\[Phi],{i,j},dyad])
+(k-i+1)j(theta[{3,-np}][DyadComponentByNumberSymmetric[\[Phi],{i,j-1},dyad]]+i*\[Tau]dyad*DyadComponentByNumberSymmetric[\[Phi],{i,j-1},dyad] + (l-j+1)*Dagger[\[Tau]pdyad]*DyadComponentByNumberSymmetric[\[Phi],{i,j-1},dyad])
+i(l-j+1)(theta[{4,-np}][DyadComponentByNumberSymmetric[\[Phi],{i-1,j},dyad]]+(k-i+1)*\[Tau]pdyad*DyadComponentByNumberSymmetric[\[Phi],{i-1,j},dyad] + j*Dagger[\[Tau]dyad]*DyadComponentByNumberSymmetric[\[Phi],{i-1,j},dyad])
+i j(theta[{2,-np}][DyadComponentByNumberSymmetric[\[Phi],{i-1,j-1},dyad]]+(k-i+1)*\[Rho]pdyad*DyadComponentByNumberSymmetric[\[Phi],{i-1,j-1},dyad] + (l-j+1)*Dagger[\[Rho]pdyad]*DyadComponentByNumberSymmetric[\[Phi],{i-1,j-1},dyad])
+(k-i+1)(k-i)(l-j+1)*\[Kappa]dyad*DyadComponentByNumberSymmetric[\[Phi],{i+1,j},dyad]
+(k-i+1)(k-i)j*\[Sigma]dyad*DyadComponentByNumberSymmetric[\[Phi],{i+1,j-1},dyad]
+i(i-1)(l-j+1)*\[Sigma]pdyad*DyadComponentByNumberSymmetric[\[Phi],{i-2,j},dyad]
+i(i-1)j*\[Kappa]pdyad*DyadComponentByNumberSymmetric[\[Phi],{i-2,j-1},dyad]
+(k-i+1)(l-j+1)(l-j)*Dagger[\[Kappa]dyad]*DyadComponentByNumberSymmetric[\[Phi],{i,j+1},dyad]
+i(l-j+1)(l-j)*Dagger[\[Sigma]dyad]*DyadComponentByNumberSymmetric[\[Phi],{i-1,j+1},dyad]
+(k-i+1)j(j-1)*Dagger[\[Sigma]pdyad]*DyadComponentByNumberSymmetric[\[Phi],{i,j-2},dyad]
+i j (j-1)*Dagger[\[Kappa]pdyad]*DyadComponentByNumberSymmetric[\[Phi],{i-1,j-2},dyad])
,{i,0,k+1}],{j,0,l+1}]]//.$GHPExtraRules]/.GHPComponentRules[\[Phi],dyad]//.$GHPExtraRules]];


(* ::Input::Initialization:: *)
GHPComponentRules[DivCDe[\[Phi]_?xTensorQ],dyad_]:=GHPComponentRules[DivCDe[\[Phi]],dyad]=Module[{i,j,k=NumOfUnprimedSlotsDyad[dyad]@\[Phi],l=NumOfPrimedSlotsDyad[dyad]@\[Phi],\[Kappa]dyad=GHPSpinCoefficients[dyad][[1]],
\[Rho]dyad=GHPSpinCoefficients[dyad][[2]],
\[Sigma]dyad=GHPSpinCoefficients[dyad][[3]],
\[Tau]dyad=GHPSpinCoefficients[dyad][[4]],
\[Kappa]pdyad=GHPSpinCoefficients[dyad][[5]],
\[Rho]pdyad=GHPSpinCoefficients[dyad][[6]],
\[Sigma]pdyad=GHPSpinCoefficients[dyad][[7]],
\[Tau]pdyad=GHPSpinCoefficients[dyad][[8]],theta=SymbolJoin["\[CapitalTheta]",dyad],np=TetradOfDyad[dyad]},
SetGHPWeightAndFormatSymmetric[\[Phi],dyad];
SetGHPWeightAndFormatSymmetric[DivCDe[\[Phi]],dyad];
If[$DyadCalcInfo,Print["Calculating the ",dyad,"components of ",DivCDe[\[Phi]]," in GHP form. (Improved code)"]];
Expand[Expand[Flatten[Table[Table[DyadComponentByNumberSymmetric[DivCDe[\[Phi]],{i,j},dyad]->(theta[{1,-np}][DyadComponentByNumberSymmetric[\[Phi],{i+1,j+1},dyad]]-(k-i)*\[Rho]dyad*DyadComponentByNumberSymmetric[\[Phi],{i+1,j+1},dyad] -(l-j)*Dagger[\[Rho]dyad]*DyadComponentByNumberSymmetric[\[Phi],{i+1,j+1},dyad])
+(theta[{2,-np}][DyadComponentByNumberSymmetric[\[Phi],{i,j},dyad]]-(i+1)*\[Rho]pdyad*DyadComponentByNumberSymmetric[\[Phi],{i,j},dyad] -(j+1)*Dagger[\[Rho]pdyad]*DyadComponentByNumberSymmetric[\[Phi],{i,j},dyad])
-(theta[{3,-np}][DyadComponentByNumberSymmetric[\[Phi],{i+1,j},dyad]]-(k-i)*\[Tau]dyad*DyadComponentByNumberSymmetric[\[Phi],{i+1,j},dyad] -(j+1)*Dagger[\[Tau]pdyad]*DyadComponentByNumberSymmetric[\[Phi],{i+1,j},dyad])
-(theta[{4,-np}][DyadComponentByNumberSymmetric[\[Phi],{i,j+1},dyad]]-(i+1)*\[Tau]pdyad*DyadComponentByNumberSymmetric[\[Phi],{i,j+1},dyad] -(l-j)*Dagger[\[Tau]dyad]*DyadComponentByNumberSymmetric[\[Phi],{i,j+1},dyad])
+(k-i-1)*\[Kappa]dyad*DyadComponentByNumberSymmetric[\[Phi],{i+2,j+1},dyad]
-(k-i-1)*\[Sigma]dyad*DyadComponentByNumberSymmetric[\[Phi],{i+2,j},dyad]
-i*\[Sigma]pdyad*DyadComponentByNumberSymmetric[\[Phi],{i-1,j+1},dyad]
+i*\[Kappa]pdyad*DyadComponentByNumberSymmetric[\[Phi],{i-1,j},dyad]
+(l-j-1)*Dagger[\[Kappa]dyad]*DyadComponentByNumberSymmetric[\[Phi],{i+1,j+2},dyad]
-(l-j-1)*Dagger[\[Sigma]dyad]*DyadComponentByNumberSymmetric[\[Phi],{i,j+2},dyad]
-j*Dagger[\[Sigma]pdyad]*DyadComponentByNumberSymmetric[\[Phi],{i+1,j-1},dyad]
+j*Dagger[\[Kappa]pdyad]*DyadComponentByNumberSymmetric[\[Phi],{i,j-1},dyad]
,{i,0,k-1}],{j,0,l-1}]]//.$GHPExtraRules]/.GHPComponentRules[\[Phi],dyad]//.$GHPExtraRules]];


(* ::Input::Initialization:: *)
GHPComponentRules[CurlCDe[\[Phi]_?xTensorQ],dyad_]:=GHPComponentRules[CurlCDe[\[Phi]],dyad]=Module[{i,j,k=NumOfUnprimedSlotsDyad[dyad]@\[Phi],l=NumOfPrimedSlotsDyad[dyad]@\[Phi],\[Kappa]dyad=GHPSpinCoefficients[dyad][[1]],
\[Rho]dyad=GHPSpinCoefficients[dyad][[2]],
\[Sigma]dyad=GHPSpinCoefficients[dyad][[3]],
\[Tau]dyad=GHPSpinCoefficients[dyad][[4]],
\[Kappa]pdyad=GHPSpinCoefficients[dyad][[5]],
\[Rho]pdyad=GHPSpinCoefficients[dyad][[6]],
\[Sigma]pdyad=GHPSpinCoefficients[dyad][[7]],
\[Tau]pdyad=GHPSpinCoefficients[dyad][[8]],theta=SymbolJoin["\[CapitalTheta]",dyad],np=TetradOfDyad[dyad]},
SetGHPWeightAndFormatSymmetric[\[Phi],dyad];
SetGHPWeightAndFormatSymmetric[CurlCDe[\[Phi]],dyad];
If[$DyadCalcInfo,Print["Calculating the ",dyad,"components of ",CurlCDe[\[Phi]]," in GHP form. (Improved code)"]];
Expand[Expand[Flatten[Table[Table[DyadComponentByNumberSymmetric[CurlCDe[\[Phi]],{i,j},dyad]->
1/(k+1)(-(k-i+1)*(theta[{1,-np}][DyadComponentByNumberSymmetric[\[Phi],{i,j+1},dyad]]
+i*\[Rho]dyad*DyadComponentByNumberSymmetric[\[Phi],{i,j+1},dyad] 
-(l-j)*Dagger[\[Rho]dyad]*DyadComponentByNumberSymmetric[\[Phi],{i,j+1},dyad])
+i*(theta[{2,-np}][DyadComponentByNumberSymmetric[\[Phi],{i-1,j},dyad]]
+(k-i+1)*\[Rho]pdyad*DyadComponentByNumberSymmetric[\[Phi],{i-1,j},dyad] 
-(j+1)*Dagger[\[Rho]pdyad]*DyadComponentByNumberSymmetric[\[Phi],{i-1,j},dyad])
+(k-i+1)*(theta[{3,-np}][DyadComponentByNumberSymmetric[\[Phi],{i,j},dyad]]
+i*\[Tau]dyad*DyadComponentByNumberSymmetric[\[Phi],{i,j},dyad] 
-(j+1)*Dagger[\[Tau]pdyad]*DyadComponentByNumberSymmetric[\[Phi],{i,j},dyad])
-i*(theta[{4,-np}][DyadComponentByNumberSymmetric[\[Phi],{i-1,j+1},dyad]]
+(k-i+1)*\[Tau]pdyad*DyadComponentByNumberSymmetric[\[Phi],{i-1,j+1},dyad] 
-(l-j)*Dagger[\[Tau]dyad]*DyadComponentByNumberSymmetric[\[Phi],{i-1,j+1},dyad])
-(k-i+1)(k-i)*\[Kappa]dyad*DyadComponentByNumberSymmetric[\[Phi],{i+1,j+1},dyad]
+(k-i+1)(k-i)*\[Sigma]dyad*DyadComponentByNumberSymmetric[\[Phi],{i+1,j},dyad]
-i(i-1)*\[Sigma]pdyad*DyadComponentByNumberSymmetric[\[Phi],{i-2,j+1},dyad]
+i(i-1)*\[Kappa]pdyad*DyadComponentByNumberSymmetric[\[Phi],{i-2,j},dyad]
-(k-i+1)(l-j-1)*Dagger[\[Kappa]dyad]*DyadComponentByNumberSymmetric[\[Phi],{i,j+2},dyad]
-i(l-j-1)*Dagger[\[Sigma]dyad]*DyadComponentByNumberSymmetric[\[Phi],{i-1,j+2},dyad]
+(k-i+1)j*Dagger[\[Sigma]pdyad]*DyadComponentByNumberSymmetric[\[Phi],{i,j-1},dyad]
+i*j*Dagger[\[Kappa]pdyad]*DyadComponentByNumberSymmetric[\[Phi],{i-1,j-1},dyad])
,{i,0,k+1}],{j,0,l-1}]]//.$GHPExtraRules]/.GHPComponentRules[\[Phi],dyad]//.$GHPExtraRules]];


(* ::Input::Initialization:: *)
GHPComponentRules[CurlDgCDe[\[Phi]_?xTensorQ],dyad_]:=GHPComponentRules[CurlDgCDe[\[Phi]],dyad]=Module[{i,j,k=NumOfUnprimedSlotsDyad[dyad]@\[Phi],l=NumOfPrimedSlotsDyad[dyad]@\[Phi],\[Kappa]dyad=GHPSpinCoefficients[dyad][[1]],
\[Rho]dyad=GHPSpinCoefficients[dyad][[2]],
\[Sigma]dyad=GHPSpinCoefficients[dyad][[3]],
\[Tau]dyad=GHPSpinCoefficients[dyad][[4]],
\[Kappa]pdyad=GHPSpinCoefficients[dyad][[5]],
\[Rho]pdyad=GHPSpinCoefficients[dyad][[6]],
\[Sigma]pdyad=GHPSpinCoefficients[dyad][[7]],
\[Tau]pdyad=GHPSpinCoefficients[dyad][[8]],theta=SymbolJoin["\[CapitalTheta]",dyad],np=TetradOfDyad[dyad]},
SetGHPWeightAndFormatSymmetric[\[Phi],dyad];
SetGHPWeightAndFormatSymmetric[CurlDgCDe[\[Phi]],dyad];
If[$DyadCalcInfo,Print["Calculating the ",dyad,"components of ",CurlDgCDe[\[Phi]]," in GHP form. (Improved code)"]];
Expand[Expand[Flatten[Table[Table[DyadComponentByNumberSymmetric[CurlDgCDe[\[Phi]],{i,j},dyad]->
1/(l+1)(-(l-j+1)*(theta[{1,-np}][DyadComponentByNumberSymmetric[\[Phi],{i+1,j},dyad]]
+j*Dagger[\[Rho]dyad]*DyadComponentByNumberSymmetric[\[Phi],{i+1,j},dyad] 
-(k-i)*\[Rho]dyad*DyadComponentByNumberSymmetric[\[Phi],{i+1,j},dyad])
+j*(theta[{2,-np}][DyadComponentByNumberSymmetric[\[Phi],{i,j-1},dyad]]
+(l-j+1)*Dagger[\[Rho]pdyad]*DyadComponentByNumberSymmetric[\[Phi],{i,j-1},dyad] 
-(i+1)*\[Rho]pdyad*DyadComponentByNumberSymmetric[\[Phi],{i,j-1},dyad])
+(l-j+1)*(theta[{4,-np}][DyadComponentByNumberSymmetric[\[Phi],{i,j},dyad]]
+j*Dagger[\[Tau]dyad]*DyadComponentByNumberSymmetric[\[Phi],{i,j},dyad] 
-(i+1)*\[Tau]pdyad*DyadComponentByNumberSymmetric[\[Phi],{i,j},dyad])
-j*(theta[{3,-np}][DyadComponentByNumberSymmetric[\[Phi],{i+1,j-1},dyad]]
+(l-j+1)*Dagger[\[Tau]pdyad]*DyadComponentByNumberSymmetric[\[Phi],{i+1,j-1},dyad] 
-(k-i)*\[Tau]dyad*DyadComponentByNumberSymmetric[\[Phi],{i+1,j-1},dyad])
-(l-j+1)(l-j)*Dagger[\[Kappa]dyad]*DyadComponentByNumberSymmetric[\[Phi],{i+1,j+1},dyad]
+(l-j+1)(l-j)*Dagger[\[Sigma]dyad]*DyadComponentByNumberSymmetric[\[Phi],{i,j+1},dyad]
-j(j-1)*Dagger[\[Sigma]pdyad]*DyadComponentByNumberSymmetric[\[Phi],{i+1,j-2},dyad]
+j(j-1)*Dagger[\[Kappa]pdyad]*DyadComponentByNumberSymmetric[\[Phi],{i,j-2},dyad]
-(l-j+1)(k-i-1)*\[Kappa]dyad*DyadComponentByNumberSymmetric[\[Phi],{i+2,j},dyad]
-j(k-i-1)*\[Sigma]dyad*DyadComponentByNumberSymmetric[\[Phi],{i+2,j-1},dyad]
+(l-j+1)i*\[Sigma]pdyad*DyadComponentByNumberSymmetric[\[Phi],{i-1,j},dyad]
+i*j*\[Kappa]pdyad*DyadComponentByNumberSymmetric[\[Phi],{i-1,j-1},dyad])
,{i,0,k-1}],{j,0,l+1}]]//.$GHPExtraRules]/.GHPComponentRules[\[Phi],dyad]//.$GHPExtraRules]];


(* ::Input::Initialization:: *)
GHPComponentRules[lhs:(MultScal[s_,\[Phi]_?xTensorQ]),dyad_]:=GHPComponentRules[lhs,dyad]=With[{k=NumOfUnprimedSlotsDyad[dyad]@lhs,l=NumOfPrimedSlotsDyad[dyad]@lhs,comps=AllDyadComponentsSymmetric[lhs,dyad]},
SetGHPWeightAndFormatSymmetric[lhs,dyad];
Thread[comps->Expand[Expand[comps//.MultScalRule//.$GHPExtraRules]/.GHPComponentRules[\[Phi],dyad]//.$GHPExtraRules]]];


(* ::Input::Initialization:: *)
GHPComponentRules[(op_?FundSpinOpQ)[TT_?xTensorQ, extr___], dyad_] := GHPComponentRules[op[TT, extr], dyad] = Module[{lhs = GiveIndicesToTensor[op[TT, extr]], rhs, spin = VBundleOfBasis@dyad},
        (* Make sure the GHPWeights and Tex output are set by expanding into dyad *)
        DyadExpansionEq[op[TT, extr], dyad];
        If[$DyadCalcInfo, Print["Calculating the ", dyad, "components of ", lhs, " in GHP form."]];
        rhs = xAct`SpinFrames`Private`GHPFundSpinopExpandFunction@lhs;
        If[Length[Select[SlotsOfTensor[TT], Or[UpIndex[#] === spin, UpIndex[#] === Dagger@spin] &]] > 0, rhs = rhs /. ToRule@DyadExpansionEq[TT, dyad] /. xAct`SpinFrames`Private`$GHPExtraDyadExpansions];

Expand[DyadComponents[lhs == Expand[ToCanonical[Expand[Expand[rhs] /. CovDDyadRules[dyad]] /. CovDToGHPRules[dyad] /. NPToGHPSpinCoeffs[dyad] //. $GHPExtraRules]], dyad] /. GHPComponentRules[TT, dyad] //. $GHPExtraRules] /. Equal -> Rule];


(* ::Input::Initialization:: *)
GHPComponentRulesOld[(op_?FundSpinOpQ)[TT_?xTensorQ, extr___], dyad_] := GHPComponentRulesOld[op[TT, extr], dyad] = Module[{lhs = GiveIndicesToTensor[op[TT, extr]], rhs, spin = VBundleOfBasis@dyad},
        (* Make sure the GHPWeights and Tex output are set by expanding into dyad *)
        DyadExpansionEq[op[TT, extr], dyad];
        If[$DyadCalcInfo, Print["Calculating the ", dyad, "components of ", lhs, " in GHP form."]];
        rhs = xAct`SpinFrames`Private`GHPFundSpinopExpandFunction@lhs;
        If[Length[Select[SlotsOfTensor[TT], Or[UpIndex[#] === spin, UpIndex[#] === Dagger@spin] &]] > 0, rhs = rhs /. ToRule@DyadExpansionEq[TT, dyad] /. xAct`SpinFrames`Private`$GHPExtraDyadExpansions];
        Expand[DyadComponents[lhs == Expand[ToCanonical[Expand[Expand[rhs] /. CovDDyadRules[dyad]] /. CovDToGHPRules[dyad] /. NPToGHPSpinCoeffs[dyad] //. $GHPExtraRules]], dyad] /. GHPComponentRules[TT, dyad] //. $GHPExtraRules] /. Equal -> Rule];


(* ::Input::Initialization:: *)
GHPComponentRules[SymMult[\[Phi]_?xTensorQ,m_,n_][\[CurlyPhi]_?xTensorQ],dyad_]:=GHPComponentRules[SymMult[\[Phi],m,n][\[CurlyPhi]],dyad]=Module[{s,r,t,u,p,q,i=NumOfUnprimedSlotsDyad[dyad]@\[Phi],j=NumOfPrimedSlotsDyad[dyad]@\[Phi],k=NumOfUnprimedSlotsDyad[dyad]@\[CurlyPhi],l=NumOfPrimedSlotsDyad[dyad]@\[CurlyPhi]},
SetGHPWeightAndFormatSymmetric[\[CurlyPhi],dyad];
SetGHPWeightAndFormatSymmetric[\[Phi],dyad];
SetGHPWeightAndFormatSymmetric[SymMult[\[Phi],m,n][\[CurlyPhi]],dyad];
If[$DyadCalcInfo,Print["Calculating the ",dyad,"components of ",SymMult[\[Phi],m,n][\[CurlyPhi]]," in GHP form. (Improved code)"]];
Expand[Expand[Flatten[Table[DyadComponentByNumberSymmetric[SymMult[\[Phi],m,n][\[CurlyPhi]],{s,t},dyad]->Sum[Sum[(-1)^p*Binomial[i,r]Binomial[i-r,p]Binomial[r,m-p]Binomial[k,s+m-r]Binomial[k-s-m+r,m-p]Binomial[s+m-r,p]/(Binomial[i,m]Binomial[k,m]Binomial[m,p]Binomial[i+k-2m,s]),{p,0,m}]Sum[(-1)^q*Binomial[j,u]Binomial[j-u,q]Binomial[u,n-q]Binomial[l,t+n-u]Binomial[l-t-n+u,n-q]Binomial[t+n-u,q]/(Binomial[j,n]Binomial[l,n]Binomial[n,q]Binomial[j+l-2n,t]),{q,0,n}]DyadComponentByNumberSymmetric[\[Phi],{r,u},dyad]DyadComponentByNumberSymmetric[\[CurlyPhi],{s+m-r,t+n-u},dyad],{r,s+m-k,s+m},{u,t+n-l,t+n}],{s,0,i+k-2m},{t,0,j+l-2n}]]//.$GHPExtraRules]/.GHPComponentRules[\[Phi],dyad]/.GHPComponentRules[\[CurlyPhi],dyad]//.$GHPExtraRules]];


(* ::Input::Initialization:: *)
ToGHPComponents[expr_,dyad_]:=ToGHPComponents1[expr,dyad]


(* ::Input::Initialization:: *)
ToGHPComponents1[0==expr_,dyad_]:=(0==#&)/@ToGHPComponents1[expr,dyad]
ToGHPComponents1[expr_==0,dyad_]:=(#==0&)/@ToGHPComponents1[expr,dyad]
ToGHPComponents1[expr_Equal,dyad_]:=Thread[ToGHPComponents1[#,dyad]&/@expr]
ToGHPComponents1[expr_Plus,dyad_]:=ToGHPComponents1[#,dyad]&/@expr
ToGHPComponents1[expr_TensorPlus,dyad_]:=ToGHPComponents1[#,dyad]&/@Plus@@expr
ToGHPComponents1[Times[c_?ScalarQ,more__],dyad_]:=Expand[c*ToGHPComponents1[Times[more],dyad]]


(* ::Input::Initialization:: *)
ToGHPComponents1[\[Phi]_?xTensorQ,dyad_]:=(SetGHPWeightAndFormatSymmetric[\[Phi],dyad];AllDyadComponentsSymmetric[\[Phi],dyad])/.GHPComponentRules[\[Phi],dyad]


(* ::Input::Initialization:: *)
ToGHPComponents1[\[Phi]_?xTensorQ[inds___],dyad_]:=(SetGHPWeightAndFormatSymmetric[\[Phi],dyad];AllDyadComponentsSymmetric[\[Phi],dyad])/.GHPComponentRules[\[Phi],dyad]


(* ::Input::Initialization:: *)
TexTikzNode1[{p_,q_},str_,w_]:=StringJoin["\\draw[white,fill] (",Tex@p,",",Tex@q,") ellipse(",Tex[Round[w/2+2]],"pt and 6pt) ;\n\\draw[blue] (",Tex@p,",",Tex@q,")  node{$",str,"$};"]


(* ::Input::Initialization:: *)
TexTikzNodes[l_List]:=Module[{gatheredexprs=GatherBy[l,GHPWeightOf],texedparts,weights,widths,FFF},
weights=GHPWeightOf@First[#]&/@gatheredexprs;
texedparts=StringJoin@@Riffle[Tex/@#,","]&/@gatheredexprs;
widths=Rest[xAct`TexAct`Private`TexWidths@@texedparts];StringJoin@@Riffle[Thread@FFF[weights,texedparts,widths]/.FFF->TexTikzNode1,"\n"]]


(* ::Input::Initialization:: *)
$TexGHPTikzFigureStart="\\begin{tikzpicture}[xscale=1,yscale=1]
\\filldraw[draw=white,fill=yellow!10!white]
(-4.9,-3.9) rectangle (4.9,3.9);
\\draw[step=1cm,gray, dotted, thin] (-4.9,-3.9) grid (4.9,3.9);
\\draw[very thin, gray, ->] (-4.9,0) -- (4.9,0);
\\draw[very thin,gray, ->] (0,-3.9) -- (0,3.9);
\\draw (4.9,0) node[anchor=west]{$p$};
\\draw (0,3.9) node[anchor=south]{$q$};";


(* ::Input::Initialization:: *)
$TexGHPTikzFigureEnd="\\filldraw[draw=white,fill=blue!4!white]
(2.8,1.8) rectangle (5.2,4.2);
\\draw[very thin,gray, ->,shorten >=7pt,shorten <=2pt] (4,3) -- (5,4) node {$\\tho$};
\\draw[very thin,gray, ->,shorten >=7pt,shorten <=2pt] (4,3) -- (3,2) node{$\\tho'$};
\\draw[very thin,gray, ->,shorten >=7pt,shorten <=2pt] (4,3) -- (5,2) node {$\\edt$} ;
\\draw[very thin,gray, ->,shorten >=7pt,shorten <=2pt] (4,3) -- (3,4) node {$\\edt'$} ;
\\end{tikzpicture}"


(* ::Input::Initialization:: *)
TexGHPTikzFigure[l_List]:=StringJoin[$TexGHPTikzFigureStart,TexTikzNodes[l],$TexGHPTikzFigureEnd]
