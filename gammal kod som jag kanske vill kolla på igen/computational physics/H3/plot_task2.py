import numpy as np
import matplotlib as mpl
from matplotlib import pyplot as plt
import struct

### for plotting nice plots ###
width = 6
height = width / 1.5
fsize = 16
font = {'size': fsize}
mpl.rc('font', **font)
mpl.rc('xtick', labelsize=fsize)
mpl.rc('ytick', labelsize=fsize)
mpl.rc('text', usetex=False)

### write down exact Fourier transform ###
hbar = 0.658212 # [eV fs]
hydrogen_mass = 104.5 # [eV fs^2 / A^2]
x0 = 0.0 # mean position

def psi_p(p):
    return (d**2 / (np.pi * hbar**2))**(1 / 4) * \
		np.exp(-d**2 * (p - p0)**2 / (2 * hbar**2)) * \
		np.exp(-1j * p * x0 / hbar)

### read binary files generated by C ###
x_list = np.fromfile("data/x_list_task2.bin")
p_list = np.fromfile("data/p_list_task2.bin")
real_psi_x_list = np.fromfile("data/real_psi_x_list_task2.bin") # real_psi_x_list[x_index + x_list_length * time_index], [A^(-1/2)]
imag_psi_x_list = np.fromfile("data/imag_psi_x_list_task2.bin")
real_psi_p_list = np.fromfile("data/real_psi_p_list_task2.bin")
imag_psi_p_list = np.fromfile("data/imag_psi_p_list_task2.bin")
parameters = np.fromfile("data/parameters_task2.bin") # {x0, x_max, x_list_length, timestep, nbr_timesteps, p0, d}

### extract parameters ###
x_list_length = int(parameters[2])
timestep = parameters[3]
nbr_timesteps = int(parameters[4])
p0 = parameters[5] # [] 
d = parameters[6] # wavepacket width [A]

### sort p_lists ###
idx   = np.argsort(p_list)
p_list = np.array(p_list)[idx]

### plot probability densities ###
probs_x = real_psi_x_list**2 + imag_psi_x_list**2
probs_p = real_psi_p_list**2 + imag_psi_p_list**2

fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(8,4), sharey=True)
skip = 200 # for not as packed plotting
time_factor = 0.1
wavepacket_width_x = np.zeros(nbr_timesteps) # initiate
wavepacket_width_p = np.zeros(nbr_timesteps) # initiate
for time_index in range(0, nbr_timesteps, skip):
	current_probs_x = probs_x[x_list_length * time_index:x_list_length * (time_index + 1)]
	current_probs_p = probs_p[x_list_length * time_index:x_list_length * (time_index + 1)]
	current_probs_p = np.array(current_probs_p)[idx] # sort according to p_list sorting

	# find width of wave packet
	x_sublist = x_list[current_probs_x > np.exp(-1 / 2.0) * max(current_probs_x)]
	p_sublist = p_list[current_probs_p > np.exp(-1 / 2.0) * max(current_probs_p)]
	wavepacket_width_x[time_index] = (max(x_sublist) - min(x_sublist)) / np.sqrt(2.0)
	wavepacket_width_p[time_index] = (max(p_sublist) - min(p_sublist)) / np.sqrt(2.0)

	# renormalize for aesthetics
	current_probs_x *= 33.0 # normalization doesn't matter and this looks better
	current_probs_p *= 88.0 # normalization doesn't matter and this looks better

	# actually plot
	ax1.fill_between(x_list, -current_probs_x + timestep * time_index, y2=timestep * time_index, color='white', zorder=2 * time_index)
	ax1.plot(x_list, -current_probs_x + timestep * time_index, color='black', zorder=2 * time_index + 1)
	ax2.fill_between(p_list, -current_probs_p + timestep * time_index, y2=timestep * time_index, color='white', zorder=2 * time_index)
	ax2.plot(p_list, -current_probs_p + timestep * time_index, color='black', zorder=2 * time_index + 1)

ax1.set_xlabel(r'$x$ [A]')
ax1.set_ylabel(r'$t$ [fs]')
ax1.set_xlim([-1.5, 11])
ax1.set_ylim([timestep * nbr_timesteps, -40]) # note the reverse order
ax2.set_xlabel(r'$p$ [eV fs / A]')
ax2.set_xlim([-10.0, 15.0])

### legend & save file ###
plt.tight_layout()
filename = f'figures/task2.pdf'
plt.savefig(filename)
filename = f'figures/task2.png'
plt.savefig(filename)
plt.show()


### plot wavepacket time evolution ###
t = timestep * np.array([i for i in range(nbr_timesteps)])
fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(8,4), sharey=False)
ax1.plot(t[::skip], wavepacket_width_x[::skip], '.', label=r'simulated')
ax1.plot(t[::skip], np.sqrt(d**2 + hbar**2 * t**2 / (hydrogen_mass**2 * d**2))[::skip], '-', label=r'analytic')
ax1.set_xlabel(r'$t$ [fs]')
ax1.set_ylabel(r'$P(x)$ width [A]')
ax2.plot(t[::skip], wavepacket_width_p[::skip] / np.sqrt(2.0), '.', label=r'simulated')
ax2.plot(t[::skip], hbar**2 / (2 * d**2) * np.ones(t[::skip].shape), '-', label=r'analytic')
ax2.set_xlabel(r'$t$ [fs]')
ax2.set_ylabel(r'$P(p)$ width [eV fs / A]')
ax2.set_ylim([0.0, 1.2])

### legend & save file ###
ax1.legend()
ax2.legend()
plt.tight_layout()
filename = f'figures/wavepacket_width_task2.pdf'
plt.savefig(filename)
filename = f'figures/wavepacket_width_task2.png'
plt.savefig(filename)
plt.show()
